

# 가치 기반 강화 학습

## Stable Baselines


그래서 이 오픈 AI에서 원래 강화학습을 제일 열심히 파는 데가 두 군데입니다

딥마인드랑 오픈 AI인데 요즘에는 오픈 AI가 이유는 잘 모르겠지만 논문수도 좀 줄고 약간 강화학습에 관심이 떨어진 모습을 보여주거든요

딥마인드는 여전히 열심히 하고 있고 왜 그런가

생각을 해보면은 이건 제 추측이지만 오픈 AI가 이제 채찌 PT 나오고 나서는 약간 다른 데에 신경을 덜 쓰고 채찌 PT로 바쁜 것 같아요

약간 우리 이제 이것저것 벌리지 않고 채찌 PT만 열심히 하겠다 약간 이런 느낌인 것 같은데 어쨌든 그래서 오픈 AI에서 베이스 라인즈라는 강화학습 라이브러리를 만듭니다

이름이 왜 베이스 라인즈냐면 베이스 라인이라는 게 기준선이라는 뜻이잖아요

내가 기준선을 딱 그어놓을게요

왜냐하면 강화학습 연구를 하려면 내가 다른 방법이랑 비교를 해야 되는데 다른 방법도 그러면 내 방법도 구현을 해야 되는데 다른 방법도 구현을 해야 되잖아요

보통 논문을 어떻게 쓰냐면 남의 방법은 이만큼 하는데 내 방법은 이만큼 한다 내 방법이 좋다 이렇게 논문을 쓰는데 문제는 뭐냐면 남의 방법을 구현을 정확하게 안 하면 이게 성능이 떨어진 이유가 그냥 내가 잘못 구현해서 그럴 수도 있거든요

그래서 오픈 AI에서 딱 돼 내가 기준선을 딱 잡아 줄 테니까 지금 유명한 알고리즘은 내가 다 정확하게 구현을 해 놓을 테니까 이거랑 비교해 너 만든 방법 네가 구현해 가지고 엉터리를 구현하지 말고 내가 구현해 줄 테니까 이거랑 기준선으로 딱 비교를 해라 라고 해서 이제 베이스 라인즈라는 거를 만들게 되고요 이거를 이제 여러 번 포크가 일어납니다

그래서 오픈 AI에서 베이스 라인즈는 더 이상 개발을 안 하고 있고 이걸 한번 포크를 해서 텐서플로우 기반으로 만들고 근데 이제 사람들이 텐서플로우를 안 쓰니까 파이토치 기반으로 한 번 더 포크가 돼서 현재 스테이블 베이스 라인즈 3라는 이름으로 돼 있는데 현재 가장 많이 사용되는 강화학습 라이브럴입니다

그 약간 굉장히 근본 있는 라이브럴이라고 할 수 있죠

그 조상이 이제 뼈대가 있는 집안 출신입니다

그래서 이제 이거는 이것도 정확하게 구현되어 있느냐 사실 그걸 장담할 수 있는 사람은 없지만 오픈 AI에서 구현한 게 틀렸으면은 뭐 우리도 틀릴 거니까 그 사람들보다 더 잘 하기는 쉽지 않겠죠

그래서 우리가 이제 DQN이라든지 앞으로 수업 시간에 배울 주요한 강화학습 알고리즘은 여기 다 구현이 되어 있습니다

약간 여기 안 들어가 있으면 그 일단 네임드가 아닌 거예요

이름 있는 알고리즘은 여기 다 들어갔으니까 여기 없는 거는 그러니까 최신 알고리즘들은 여기 없겠죠

근데 다른 알고리즘과 비교한 어떤 기준선이 될 만한 알고리즘은 여기 다 들어가 있기 때문에 이것만 쓰셔도 우리가 막 엄청 최신까지 아니면은 웬만큼은 커버가 된다

그리고 최신 알고리즘은 좀 주의를 하셔야 되는 게 검증이 잘 안 돼 있기 때문에 논문에서는 좋다고 하는데 다른 데 적용해 보면 또 아닐 수도 있거든요

제 생각에는 여기 들어간 것만 이해하고 쓰셔도 어쨌든 학계에서 이 정도는 기준선을 사흘마다 확립된 것들이 들어가 있기 때문에 이거를 쓰시는 게 좋을 것 같다

이렇게 생각이 되고요 그래서 우리는 앞으로 이제 이거를 쓸 겁니다

그래서 이제 공식문서는 여기 있고 소스코드는 여긴데 이것도 이제 설치를 하시려면 이렇게 설치를 하시면 되겠죠


```python copy
!pip install stable-baselines3[extra]
```


## NFQ

이번 시간에 해볼 내용은 가치기반 강화학습입니다

그래서 우리가 강화학습을 크게 두 가지로 나눌 수 있다

이런 얘기를 드렸었는데 결국에는 같이 Q를 추정을 해서 이걸로 Q가 제일 큰 행동을 하는 방식의 강화학습이 있고 정책기반의 강화학습, 그냥 Pi 자체를 추정을 해서 바로 이제 우리가 주어진 상황에 따라서 어떤 행동을 할지 계산해가지고 하는 방식이 있고 두 가지가 있다고 얘기를 드렸는데 결국에는 우리가 딥러닝을 넣어도 결국 이 Q를 딥러닝으로 만드느냐 이 Pi를 딥러닝으로 만드느냐 이 차이일 뿐이지 이전에 했던 거랑 크게 다르지는 않아요

근데 이제 딥러닝을 여기다 집어넣으면 또 복잡한 문제가 생기기 때문에 거기에 대한 해결책이 나오게 됩니다

그래서 초기에는 NFQ라고 해가지고 우리가 Q러닝을 배웠었죠

기억나시나요?

Q러닝은 오프폴리시로 Td 제어오입니다

그래서 Td는 시간차 우리가 처음부터까지 다 해가지고 수익, g를 얻는 게 아니고 g의 제기적 형태가 어떻게 돼요?

g는 r 플러스 값마 g 프라임 뭐 이렇게 되는데 프라임이란 건 다음번에 g가 됩니다

그러면은 이거를 g가 기대값으로 바꾸면 v인데 v는 r 플러스 값마 v 프라임 이렇게 되는 거죠

그럼 이 두 개가 같아야 되는데 우리가 이번에 받은 보상이 크거나 작거나 하면 얘를 고쳐야 되는 거죠

그래서 두 개를 빼가지고 r 플러스 값마 v 프라임 빼기 v 이런 형태로 해서 이번에 받은 보상을 가지고 만약에 이번에 보상을 많이 받았으면 내가 기대하는 수익은 이만큼인데 그거보다 지금 더 커진 거잖아요

그럼 기대를 높여야겠죠

내가 이번에 받은 보상이 작아졌다 그러면 기대를 낮춰야겠죠

그래서 이거를 계속 반복을 하면 내가 어떤 행동을 했을 때 어느 정도 보상을 받을 수 있는지 우리가 그 기대치를 계산을 할 수 있습니다

그래서 그게 Q러닝인데 여기서 오프폴리시로 한 거는 오프폴리시는 내 정책을 가지고 한 게 아니라 남의 정책을 가지고 이 계산을 하겠다

이 얘기고 그거를 그러면 제가 지금 v라고 쓰긴 했는데 실제로는 Q야겠죠

이것도 Q고 이 Q를 뉴럴렛으로 모방을 하면 됩니다

그래서 이걸 이제 nfq라고 하는데 우리가 강학습을 하는 방식이 두 가지가 있어요

배치로 하는 게 있고 온라인으로 하는 게 있는데 데이터 수집하고 학습을 언제 하느냐

이런 건데 우리가 앞에서는 데이터를 수집하면서 학습을 동시에 했는데 내 데이터로 하든 남의 데이터로 하든 데이터 수집하고 학습하고 이걸 동시에 했는데 nfq 같은 경우는 데이터를 수집을 한 다음에 일괄적으로 학습을 합니다

왜 그럴까요?

딥러닝이라서 그래요

딥러닝은 딥러닝하면 자다가 깨어나도 데이터가 많이 필요해

이렇게 하세요

데이터가 많이 필요하기 때문에 그래요

예전에는 표 기반으로 할 때는 데이터가 별로 필요 없습니다

그냥 숫자는 나올 때마다 표를 한 칸 한 칸 고치면 되는데 이건 뉴럴 신경망이 들어가니까 딥러닝이라서 데이터가 많이 필요하니까 일단 데이터를 좀 모아놨다가 학습을 시켜야 됩니다

그래서 환경과 상호작용을 하면서 데이터를 좀 만들어 놓고 많이 만들어야겠죠

많이 만들어요

그래서 많이 만들어서 q를 신경망으로 근사를 학습을 시켜서 근사를 하게 되는 겁니다

그래서 구현을 해야 되는데 우리가 행동가치 함수 q가 상태랑 행동이 두 개가 들어가면 여기에 가치가 나오게 되어있거든요

그래서 신경망으로 구현하려면 왼쪽처럼 구현하셔야 됩니다

그래서 여기에 상태가 들어가고 여기에 행동이 들어가면 출력으로 행동가치가 나오게 이렇게 구현을 해야 되는데 이렇게 구현을 하면 문제가 있어요 뭐가 문제냐 하면 우리가 q러닝을 할 때 q러닝을 할 때 여기다 씁시다

행동이 두 개면 계산을 두 번 해봐야 된다는 거고 행동이 100개면 100번 넣어서 100번 계산을 해봐야 된다는 얘기죠 그러면 듣기만 해도 아 괴롭잖아요 그래서 계산을 줄이기 위해서 모형을 이렇게 바꾸게 됩니다 그래서 어떻게 하냐면 여기에 상태만 들어가요 s만 들어가고 그럼 여기에다가 지금 보시면 출력이 하나였다가 두 개로 늘었죠 내가 왼쪽으로 가는 행동이 있고 오른쪽으로 가는 행동이 있으면 얘는 qs,0이 나오고 이거는 qs,1이 나오게 하는 거야 그래서 우리가 행동의 갯수가 10개면 한꺼번에 그냥 10개 행동의 가치를 그냥 한꺼번에 다 계산해줍니다 100개면 100개를 한 번에 다 계산해줍니다 

물론 들으시기에 따라서 아니 하나 넣고 하나 나오나 하나 넣고 한꺼번에 두 개 나오나 어차피 계산 양 자체는 비슷한 거 아니에요 그렇게 생각하실 수 있는데 맞습니다 계산 양은 비슷한데 얘는 직렬로 계산을 해야 되니까 앞에 계산이 끝나야 그 다음 계산을 하는 거거든요 근데 이거는 병렬로 동시에 계산을 하니까 옆에 계산이 끝났든 말든 얘 계산하는 거랑 상관없으니까 얘는 얘대로 계산하고 얘는 얘대로 계산하면 됩니다 그리고 우리가 GPU가 이런 종류의 계산을 잘 하기 때문에 모델을 이렇게 짜면 실제 속도가 훨씬 빨라요 그래서 이런 식의 구조로 오른쪽 구조로 모델을 만들게 됩니다 

그래서 지도학습에서는 오늘 아침에도 봤 듯이 어제도 해봤듯이 어떤 데이터의 레이블이 있어서 이 레이블을 예측을 하게 되어있어요 근데 강학습에서는 특히 Q학습의 경우에는 Td목표, Td목표는 아까부터 계속 쓰고 있는 R 플러스 값마 Q 프라임 빼기 Q 이게 이제 Td목표인데 이 Td목표를 최소한으로 줄여야죠 최소한으로 줄여야 되는데 그 Td목표 자체도 지금 모델에서 나오거든요 그래서 지금 문제가 뭐냐면 지도학습은 나미준 데이터로 학습을 하는데 강학습은 우리가 어떤 Q를 업데이트 해야 되는데 이 Q가 얘가 최소가 되도록 추정을 해야 된단 말이에요 그러면 자기가 학습해야 되는 대상 자체를 자기가 계산하고 있어요 그래서 오차를 계산을 할 때 얘는 역전파를 시키면 안 됩니다 얘만 업데이트를 해야 돼요 이쪽에 있는 Q만 업데이트 해야 되고 이 값 자체는 업데이트를 하면 안 돼요 얘를 업데이트하면 어떻게 되냐면 이 안으로 들어가서 원래는 내가 예를 들어서 이 행동을 하면 100이 나올 줄 알았는데 내가 실제로 행동을 해보니까 110이에요 그러면 Td목표가 플러스 10이 생기는 거잖아요 그럼 이 플러스 10에 맞도록 이 Q를 수정을 해줘야 되는데 오차 역전파를 여기까지 해주면 어떻게 되냐면 갑자기 이걸 고쳐서 나 원래 이럴 줄 알았어 이렇게 되는 거야 그러면 어떻게 됩니까? 아무것도 학습을 못 하겠죠 그런 사람도 있잖아요 꼭 자기가 잘못했는데 너 이거 왜 이렇게 했어? 그게 내가 생각 있어서 그렇게 한 거라니까 방이 어질러가지고 어렸을 때 부모님들 치우라고 그러면 그건 다 이유가 있어서 거기 놓은 거야 어질러진 거 아니라고 그런 식으로 논리를 만들면 학습이 안 되겠죠 그래서 우리가 Td 목표를 계산한 부분은 옥차 역전파에 대상해서 제외를 해야 됩니다 구현이 보면 훨씬 뭐가 이것저것 신경 쓸 게 많아요 근데 그렇게 해서 학습을 시킨다 

## 함수 근사의 문제점

### 불안정성

그럼 학습이 잘 됐냐 하면 이게 강학습이기 때문에 생겨나는 골차 푼 점들이 있습니다 그래서 강학습은 이거 하려면 이게 문제고 저거 하려면 저게 문제고 항상 문제인데 기본적으로 뭐가 문제냐면 훈련의 불안정성이 생겨요 왜 훈련의 불안정성이 생기냐면 지도학습은 데이터라는 건 이미 고정이 돼 있는 거고 난 그 고정된 걸 학습만 하면 되는데 강학습에서는 데이터가 고정되어 있지 않습니다 우리가 Q 학습을 하더라도 Q 학습을 할 때 남의 데이터로 학습을 하긴 하는데 그 남의 데이터라는 게 진짜 순수하게 남의 데이터라기보다는 내 정책이 있는데 이거를 플러스 탐색을 하기 때문에 약간 내 정책이랑 다른 정책이 생기는 거죠 그러니까 순수한 내 정책이 아니라 탐색을 하는 과정에서 약간 원래 나랑 다른 정책이 생긴 것 뿐이라서 순수하게 남의 데이터가 아닙니다 거기다가 내 정책이 바뀌면 어떻게 되겠어요 결국 남의 정책이라는 것도 바뀌게 돼 있단 말이에요 100% 남의 정책이 아니기 때문에 그래서 목표라는 것이 목표에 따라 업데이트가 되는데 목표라는 것은 결국 다음 상태의 추정치 Q'에 의존할 수밖에 없는 거고 Q가 바뀌면 결국 Q'도 바뀌게 돼 있습니다

그게 무슨 말이냐면 나는 Q를 업데이트를 하는데 Q'이 업데이트가 되면 목표도 변하고 그게 뭐냐면 내가 여기가 목표라서 여기에 있는데 여기로 가려고 했어요

그랬더니 내가 여기로 가니까 목표가 갑자기 여기로 가는 거야

어 뭐야

하고 이쪽으로 그럼 갔더니 또 목표가 갑자기 여기 있던 애가 여기로 가는 거야

어 뭐야

하고 계속 나는 내 정책을 업데이트하고 있는데 내 목표치가 계속 바뀌는 거야

곤란한 거죠

그래서 목표가 딱 고정이 돼 있고 나는 여기로 이렇게 가야 어떻게 학습을 꾸준히 할 수 있는데 계속 목표치가 바뀌면 학습을 안정적으로 하기가 힘듭니다

### iid 가정의 위배

그 다음에 이 용어는 기억을 해주시면 좋은데 통계 또는 머신러닝에 굉장히 중요한 용어로 IID라는 용어가 있어요

이 IID는 Independent and Identically Distributed 영어인데 Independent는 독립적 이런 뜻이고요 이거는 이제 여러분 아시죠

동전 던지기 하면 동전 두 개가 서로 영향을 안 미치잖아요

그런 거를 독립적이라고 하고 Identically Distributed는 Distributed는 분포인데 같은 분포에서 나왔다

이런 얘기입니다

그래서 대부분의 통계나 머신러닝 기법들은 이 IID 가정 위에 만들어져 있어요

당연한 것이 우리가 여러 가지 데이터가 있는데 걔네끼리 독립적이지 않고 서로 얽혀있으면 다 고려를 해줘야 됩니다

동전 던지기를 하는데 우리가 동전 두 개를 던져서 앞면이 나올 확률 이런 거 물어보면 그냥 1 2분의 1 곱하기 1 2분의 1 하면 됩니다

만약에 앞에 동전에 따라서 뒤에 동전의 결과가 달라진다

그럼 두 가지를 다 고려야 되니까 계산이 복잡해진단 말이에요

그냥 곱하기로 해결이 안 됩니다

만약에 분포가 동일하지 않다 이러면 더 골치 아픈데 데이터가 다 똑같은 데서 나와야 내가 그 데이터를 보고 우리가 잘 모르지만 어떤 분포가 있어서 데이터가 보니까 여기서 집중적으로 나오고 여기는 좀 뜨분뜨분 나오고 여기는 좀 뜨분뜨분 나오더라

그러면 이렇게 생겼구나

이걸 추정할 수 있는데 사실은 우리는 몰랐지만 우리는 몰랐지만 분포가 여러 개가 있어서 내 데이터가 어떤 거는 이쪽에서 나오는 거고 어디서는 여기서 나오는 거고 어디서는 여기서 나오는 거고 이러면 이걸 다 합쳐봤을 때 모양이 이상하게 되겠죠

뭐지?

약간 이렇게 됩니다

우리는 이게 사실 여러 개 분포인지

모르니까 그래서 이 두 가지를 만족한다고 가정을 하고 계산을 다 해요

근데 지금 강학습이라는 거는 어떤 정책과 정책에 따른 궤적 이 궤적이라는 건 뭐냐면 내가 어떤 상태에서 어떤 행동을 하면 그게 보상을 주고 새로운 상태가 되고 그러면 나는 또 새로운 행동을 하고 그러면 또 보상을 받고 뭐 이렇게 쭉 이어진단 말이에요

그럼 내가 앞에 한 행동이 주의한 어떤 행동하고 연관이 되니까 얘네가 독립이 아니겠죠

그래서 독립이라는 가정이 깨져버립니다

아 그래 독립인 가정인 거 깨진 건 좋아

그럼 분포라도 똑같으면 되겠지 문제는 학습을 하면서 내가 정책이 바뀌거든요 정책이 바뀌면 궤적이 바뀝니다

궤적이 바뀐다는 얘기는 분포가 바뀐다는 얘기죠

그래서 두 가지가 다 깨지는 거죠

첫 번째 아이도 깨지고 두 번째 아이디도 깨지고 그래서 예를 들면 밑에는 예시로 이해를 돕기 위해서 그려놓은 건데 실제로 이렇게 복잡하게 생긴 함수인데 우리가 데이터를 여기서만 골고루 얻지 않고 여기서만 추가라 데이터를 얻으면 우리가 이런 선이라고 잘못 착각할 수 있겠죠

첫 번째 가정이 깨지면 이런 되고 데이터가 이렇게 골고루 나오려면 독립적으로 나와야 되잖아요

그런데 그렇지 않고 한번 여기서 나오면 그 다음엔 여기서만 추가라 나오는 거예요

그다음에 원래는 이렇게 생긴 함수여서 우리가 이걸 맞추고 있었더니 갑자기 함수가 바뀌어요 환장하는 거죠

왜 갑자기 안 되지?

둘 다 만족을 해야 되는데 강화학습은 특성상 둘 다 유배하기가 쉽다

그래서 이제 nfq에서 나름대로 이걸 해결해 보려고 했는데 다 안 됐고요 잘 됐으면 우리가 이걸 배웠겠죠

## DQN

그래서 사람들이 처음에는 강화학습하고 딥러닝은 궁합이 안 맞아 이거는 안 돼

이렇게 생각을 했습니다

그런데 이제 구글 딥마인드 원래 이 회사가 히스토리가 있는데 딥마인드가 알파고 만든 회사거든요

알파고 만든 회사인데 영국 회사예요

구글은 미국 회사잖아요

얘네하고 무슨 상관이냐

구글이 딥마인드를 돈 주고 샀습니다

영국 회사인데 이 회사가 비하인드가 재밌어요

원래 영국의 옥스퍼드였나 제가 정확하게 학교는 기억하는데 옥스퍼드 아니면 케임브릿지입니다

둘 중에 하나인데 좋은 학교 두 개밖에 없으니까 너무 펴만 있나?

여러 개 있는데 제일 좋은 학교죠

그 둘 중에 굉장히 똑똑한 학생들이 한 3명쯤 있었는데 같은 학교에 다니는 대학생들이었는데 얘네가 공부는 무슨 공부냐 게임회사를 차려가지고 떼돈 벌자 우리도 그래서 게임 좋아하고 약간 덕후들이었어요

그래서 게임회사를 차려가지고 야심차게 대학생들이 게임회사를 차렸는데 어떻게 됐을까요?

망했습니다

그래서 망해가지고 회사 차렸다가 망하고 이러니까 할 게 없잖아요

그래서 안 되겠다 대학원이나 가자

그래서 이제 제가 자세한 속내는 잘 모르겠지만 회사 말아먹고 야심차게 사업을 시작해봤다가 사업을 말아먹고 대학원으로 갑니다

뿔뿔이 친구들이 흩어져서 대학원 가는데 한 명은 뇌과학을 하러 가고요 한 명은 캐나다로 유학을 가가지고 캐나다에 되게 유명한 강학습의 대가가 있거든요

그래서 강학습을 배웁니다

또 한 명은 뭘 하고 뭐 이렇게 해요

이 사람들이 다 박사를 하고 대학원을 오래 다녔겠죠

대학원을 다니고 무슨 바람이 불었는지 몰라도 야 우리 다시 사업해 볼까?

이런 박사까지 했으면 학계로 가야 되는데 병이 깊은 거죠

사업병입니다

사업병 사업병이 깊어서 옛날에 한 번 말 안 먹었으면 정신을 차려야 되는데 정신 못 차리는 거죠

자기들끼리 보면 전공이 한 사람은 뇌과학이고 한 사람은 강학습이고 어?

야 저번에는 게임 회사를 했지만 이번에는 게임하는 AI를 만들어보자

이런 그래서 딥마인드라는 회사를 차려요

그래서 이제 우리가 이제 전에는 게임을 만들었는데 이번에는 이제 게임하는 AI를 만들겠다

그래서 그게 돈이 될지 약간 그 사업 구상만 들어보면 누가 이제 여러분 뭐 조카가 아니면 사촌이 이런 걸로 나는 게임하는 AI를 만들어 보겠어

하고 한 10년 전쯤에 내가 사업을 해보려고 하니 저기 너 돈 좀 있지?

돈 없는데?

너 집 있잖아

집 좀 봐 담보를 잡혀서 나 좀 돈 좀 빌려드려봐

이거 미친 거 아니야?

약간 이런 얘기가 나오겠지만 어쨌든 그 미친 아이디어를 현실화시켰는데 물론 돈은 못 벌었어요

딥마인드가 돈을 못 버는데 이분들은 개인은 다 돈을 벌었습니다

왜냐하면 회사를 팔아서 구글 딥마인드는 회사 자체는 계속 적자예요

지금까지 창립일에 적자를 면한 적이 없다고 아마 제가 알고 있습니다

없는데 차리신 분들은 회사 팔아서 구글의 돈으로 따뜻하게 살고 계시고 어쨌든 딥마인드가 똑똑한 사람들이 많이 있잖아요

그래서 이 사람들이 딥러닝하고 강학습을 결합하는 이 어려운 거를 해냅니다

그래서 이제 어떤 하나의 아이디어를 해결한 게 아니라 여러 가지 해결책을 덕지덕지 붙여요

첫 번째는 우리가 목표가 자꾸 바뀌는 문제가 있단 말이에요

그럼 목표를 고정을 시키면 될 거 아니냐

그래서 Q를 두 개를 만듭니다

이 아이디어 어디서 많이 본 거죠

그래서 우리가 어제 했던 이중 Q학습하고 비슷한데

이중 Q학습하고는 약간 달라요

이중 Q학습에서는 맥스 Q를 할 때 이게 너무 크게 나오는 것 때문에 Q를 두 개 만드는 건데 이번에는 그 문제가 아니고 Q가 계속 Q'에 따라서 바뀌는데 Q가 바뀌면 Q'이 바뀐단 말이에요

그럼 내가 Q를 Q'에 맞춰서 하고 있는데 Q를 바꿨더니 이게 서로 바뀌더라

그럼 얘랑 얘랑 다른 Q로 하면 될 거 아니냐

그래서 Q를 두 개를 만들어서 하나는 고정을 시켜 놓고 얘를 업데이트를 합니다

그래서 우리가 공식에 보면 여기 R 플러스 맥스 Q, 여기가 Q' 부분이죠

그래서 Q' 쓰는 Q는 고정을 해놔요

그리고 얘만 업데이트를 합니다

얘만 업데이트를 하다가 그럼 나중에 이 Q랑 이 Q가 두 개가 너무 괴리가 심해져 가지고 계산이 그냥 원래 안 맞게 되거든요

그러면 적당히 한 1000번쯤 업데이트를 했으면 이거를 여기다가 덮어 쓰는 거예요

그래서 그런 식으로 목표가 자꾸 변해서 학습이 불안정한 문제를 일단 해결을 합니다 기발하죠

기발하지만 잘 생각해 보면 우리가 여러분 수업을 잘 따라 오셨으면 완전히 어떤 새로운 아이디어는 아니야

계속 어쨌든 강화학습에서 오랫동안 쌓여올던 아이디어 중에 어떤 거를 잘 꺼내서 조합을 하는 거예요

오늘부터는 아마 물론 쉽다는 얘기는 아니지만 어제 한번 들어본 얘기인데 어제 저랑 비슷한 얘기 했던 거 같은데 이러면서 약간 기시감이라고 하죠

그런 게 조금씩 드실 겁니다

그래서 이제 DQN으로 그 아타니라고 해가지고 옛날 8비트 게임기가 있어요

굉장히 오랫동안 오락기인데 나이가 좀 젊으신 분들은 안 해보신 분들도 많이 있을 건데요 보통 이제 닌텐도 게임기라고 해서 흰색이랑 빨간색이랑 섞여 있는 게임기 있거든요

이거는 그래도 좀 해보신 분들 있으실 건데 그거보다 더 한 세대 전 게임기입니다

진짜 옛날 게임기죠

사실 저도 어렸을 때는 이거 못 해봤어요

그래서 이제 이 게임기에서 나온 굉장히 옛날 고전 게임이죠

고전 게임들을 시켜봤는데 이게 인간...

그렇죠 보면 여기 나와 있는 퍼센트가 뭐냐면 인간보다 몇 퍼센트 잘하냐

이런 거고 핀볼은 아시죠

핀볼 같은 경우는 인간보다 한 25배 이 정도 더 잘하고 점수가 그래서 이제 게임마다 이렇게 점수가 있다가 이 경계에서 기준으로 해서 여기는 인간보다 못 하는 게임입니다

이게 아마 2014년?

5년?

이때 나온 논문인데 무슨 회사가 맨날 논문을 쓰는지는 모르겠지만 이게 네이처에 실리고 사람들이 와 대단하다

이런 얘기를 합니다

그리고 이제 2000...

근데 재밌는 게 이게 2014년 이쯤이었는데 2016년에 알파고로 이세돌 구단을 이기거든요

그러니까 이 속도가 엄청나죠

한 2, 3년 전에 8비트 게임기로 진짜 고전 게임을 사람보다 잘하네

못하네

이러고 있었는데 2, 3년 만에 인간 최고수 그때 이세돌 구단이 세계 랭킹 2위였는데 2, 3년 만에 세계 랭킹 2위를 이겨버리니까 와 딥마인드 대단하다

이런 얘기가 나오죠

그래서 사람들이 그럼 이 추세로 가면 2년만 더 지나면 다 잘하겠네 라고 생각했지만 그렇게 쉽지 않았던 거죠

바둑까지는 쉬웠다

근데 이제 바둑 다음이 좀 어려웠던 거고 어쨌든 그래서 이 DQN이 굉장히 혁신적인 기법이 됩니다

그리고 이제 DQN은 뭐 이건 중요한 건 아닌데 기본적으로 이 논문을 보시면 이게 이제 게임 대상으로 연구를 한 거라 가지고 그 기법들이 이제 게임 관련된 기법들이 몇 개 들어있어요

예를 들면은 보상 깎이라고 해가지고 게임마다 점수 주는 방식이 다르거든요

그래서 어떤 거는 뭐 잘하면 플러스 100점 어떤 거는 플러스 1000점 이렇게 게임마다 점수가 다르니까 이거를 가점은 무조건 플러스 1 감점은 마이너스로 바꿔서 학습하기 좀 쉽게 해 주고 그 다음에 게임 같은 경우에 이제 DQN은 입력되는 상태라는 게 뭐냐면 게임 화면을 그냥 그대로 넣어줍니다

그래서 따로 뭐 사람이 손대지 않고 게임 화면만 보고 내가 이 게임을 어떻게 해야 되는지를 알아내서 공략을 하는 방식인데 문제는 게임 화면이라는 게 1초에 수십 번 변하는데 그 수십 번 변하는 내용이 거의 비슷비슷하단 말이에요

그래서 너무 짜잘 짜잘 하기 때문에 입력을 할 때 어떻게 하냐면 화면을 실시간으로 입력을 해주는 게 아니라 현재 화면이 이거면 이거보다 0. 몇 초 전 화면 0. 몇 초 전 화면 이렇게 해서 이 화면들을 한꺼번에 동시에 넣어줍니다

왜냐면 현재 화면만 보면 예를 들면 캐릭터가 이렇게 공중에 떠 있으면 지금 이쪽으로 가는 건지 이쪽으로 가는 건지는 알 수가 없어요

그래서 이 화면이랑 그 전 화면 그 전 화면은 여기 있었다 그러면 일로 가고 있는 걸 알 수 있겠죠

그래서 몇 개의 연속 화면을 좀 띄엄띄엄띄엄 해서 입력을 해가지고 그걸 하나의 상태로 사용합니다

우리가 약간 일반적으로 생각하는 상태 개념하고는 좀 다르죠

그래서 여러분들도 예를 들면 로봇 제어를 하고 싶다

그러면 제일 쉬운 방법은 로봇을 카메라로 찍어 가지고 연속 장면으로 이렇게 모델에다가 입력을 해주시면 구현은 제일 쉽겠죠

모델이 학습하기는 좀 어렵겠죠

그래서 이렇게 움직임이 있는 경우에는 이런 식으로 우리가 처리할 수 있다

이런 아이디어를 배울 수가 있겠죠

그러면은 우리 이제 DQN을 구현을 해야 되는데 강화학습은 이 딥러닝을 이용해서 함수 근사를 하는 게 구현이 굉장히 까다롭습니다

우리가 어제에도 제가 구현을 하면 이것저것 좀 틀리고 이런 게 있잖아요

그래서 강화학습이 특히 코드 짜기가 힘들어요


흠 그 다음에 오늘부터 실습은 엄청 쉬워집니다 실습 할 게 별로 없거든요

왜냐면은 스테이블 베이스라인이 다 구형이 되었기 때문에 우리가 뭐 하는 일이 별로 없어요

그래서 이제 어제 딥러닝으로 들어가서 딥러닝으로 가 가지고 여기 카트 폴 여기 보시면 어 요 코드가 있거든요

여기 이제 랜더 에피소드 요게 필요하기 때문에 요거를 좀 쓸 겁니다

요거를 이제 복사 하셔 가지고 그 3일차 딥러닝 카트 폴에 보면 요 코드가 있는데 요거를 이제 복사를 하셔서 실행을 해 주시구요

그러면은 바로 쓰러지죠

바로 쓰러집니다

그래서 이제 랜덤 정책으로 랜덤 모델로 하니까는 바로 쓰러지는 건데 그럼 우리가 이제 dqn으로 학습을 시키면 얼마나 잘하나 요거를 한번 볼 거에요

그래서 여기 dqn 코드를 보시면 요 앞에 는 환경은 뭐 이미 만들었으니까 사실 필요 없고 여기 프롬 스테이블 베이스라인 3에서 dqn을 임포트 하시구요

그 다음에 모델 만드는 거는 다 만들어져 있기 때문에 그냥 가져다 쓰면 됩니다

dqn, mlp 팔러시 하면은 mlp 팔러시는 뭐냐면 모델도 자기가 그냥 알아서 만듭니다

그 큐를 모방하는 모델을 mlp 라는 형태로 만들어요





```python copy
import gymnasium as gym
from stable_baselines3 import DQN

# 환경
env = gym.make("CartPole-v1", render_mode="rgb_array")

# 모델
model = DQN("MlpPolicy", env, verbose=1)

# 총 1000회에 걸쳐  학습
model.learn(total_timesteps=1000, log_interval=4, progress_bar=True)
```



```python copy
# 애니메이션
render_episode(env, model)
```



```python copy
# 저장
model.save("dqn_cartpole")

# 삭제
del model

# 불러오기
model = DQN.load("dqn_cartpole")
```



여기 verbose에 나오는 건 뭐냐면 여기 보면 출력이 화면에 계속 나오죠

이게 verbose 1 이렇게 나서 그런데 이거를 0으로 하시면 이게 안 나옵니다

그래서 롤라웃은 뭐냐면 내가 한번 해보는 거잖아요

롤라웃은 정책으로 그래서 EP는 에피소드구요

LEN은 랭스 그다음에 ME는 평균 그러니까 에피소드의 길이의 평균입니다

내가 이거 지금 뭐죠

저기 카트폴을 하는데 몇 초 나 버텼냐

이거에요

그리고 보상은 두 번째 거는 뭐냐면 보상의 평균인데 지금 어차피 버틴 길이만큼 보상을 주기 때문에 얘네 두 개는 똑같습니다

그리고 TIME은 보시면 아시겠지만 걸리는 시간이고 TRAIN은 학습을 하는데 손실이랑 학습률이 어떻게 되냐

이런 거에요

그래서 지금 보시면 제 화면 보시면 18초 버텼고 손실이 0.478인데 뒤로 쭉 가면 버티는 시간이 조금씩 늘어나죠

이게 그래서 한참 뒤로 가면 버티는 시간이 아까 18초인데 209초 지금 스텝이란 사실 초는 아니에요

아까 18스텝 했는데 거의 10배로 늘어났죠

길이가 길이가 10배로 늘어나고 손실도 아까 0.4 얼마였나 그런데 0.1로 이제 감소했습니다

그래서 중간 과정을 보여주는 거예요


## 손실 함수


그 다음에 이제 후보 손실이 강학습에 가지는 장점은 뭐냐

우리가 이제 이 두 개의 차이를 줄여야 되는데 이 두 개가 빼기 해가지고 차이가 0이 되면 제일 좋은 거란 말이에요

내가 실제로 받은 보상이랑 다음 번에 받을 가치랑 그 다음에 내가 이번에 받은 가치 이건 전부 기대 값이거든요

내가 지금 기대하는 거고 회사로 치면은 내가 현재 우리 회사에 대해서 내가 기대하는 어떤 수준이 있어요

이번에 받은, 올해 받은 월급이랑 복지랑 이런 게 있고 내년쯤 되면은 이 정도를 기대하고 있어요

그럼 이 두 개를 더하면 지금 내가 기대하는 수준이 돼야 되는데 내가 회사에 보니까 이번에 어?

월급이 별로 인상이 내 생각하고 좀 달라요

그럼 내 기대가 너무 높았던 거죠

아 우리 회사가 이런 거지

아니면은 갑자기 통장을 열어보니까 어?

왜 이렇게 돈이 많이 들어왔어?

그러면은 아 우리 회사 좋은 회사인데?

기대가 높아지겠죠

그래서 이제 그거에 맞춰 조정을 하는 건데 그럼 이 차이가 딱 0이 될 때가 내가 기대를 가장 정확하게 하는 거란 말이에요

너무 기대가 높지도 않고 낮지도 않고 그럼 이게 0이 되게 하려면 어디 갔죠?

손실함수가 이렇게 0에서 딱 꺾여야겠죠

그래서 0에서 딱 바닥을 치게 돼야 되는데 제곱을 하면 이렇게 둥글게 되니까 이 근처에서 경사가 완만해져서 0으로 수렴하기가 좋습니다

근데 그 대신 제곱을 했기 때문에 이런 데 경사가 너무 급해요

이런 데서 발산할 위험이 있어요

그리고 절대 오차는 여기가 기울기가 일정하기 때문에 이 양쪽 끝에서 발산할 가능성은 별로 없는데 이 끝이 뾰족하기 때문에 여기 딱 맞추기가 쉽지가 않단 말이에요

그래서 후보 손실은 이 두 가지를 합쳐 가지고 이 0인 근처에서는 경사가 완만해져서 수렴하기가 좋고 먼 쪽에서는 경사가 일정해서 너무 치지 않고 근데 경사 강화학습은 멀리 튀는 경우가 굉장히 자주 나옵니다

이상한 경우가 많이 나와요

어?

이런 경우?

지도학습은 그런 경우가 잘 없거든요

지도학습은 대체로 데이터가 일정합니다

강화학습은 살다 보면 갑자기 어?

할 때가 있어요

그때가 학습이 일어나는 순간입니다

그래서 기본적으로 강화학습은 뭔가 튀는 점이 항상 있어요

그래서 강화학습은 뭔가 우리가 오차가 크게 발생하는 순간들이 있는데 후보 손실은 MS이나 MAELP에서 그런 점들이 강점이 있는 거죠


## TD 목표에 오차 역전파를 막는 이유

우리가 이제 Td타겟에서 오차 역전파되는 걸 왜 막냐

이거죠

경사계산에서 제외 이렇게 되는데 슬라이드 335죠

여기서 여기 노그라드 이렇게 하는 게 여기 노그라드 이렇게 하는 게 경사계산 하지 마라

이런 건데 왜냐하면은 우리가 다시 한번 공식을 봅시다

공식을 보면 이 왼쪽에 이거랑 Q랑 차이를 줄이려고 하는 거거든요

그럼 두 개의 차이를 줄여야 되는데 이 Q를 안 줄이고 이걸 바꿔버리면 목표 자체를 고치는 거란 말이에요

내가 왜 그런 거 있잖아요

넘어졌는데 안 민망한 방법은 원래부터 난 눌려고 그랬는데?

이러면 되는 거다

근데 원래부터 눌려고 그런 게 아니잖아요

내가 약간 창피를 하고 부끄러움을 무릅 써야 그다음부터 안 넘어지는데 넘어진 다음에 싹 이렇게 앉아가지고

나 원래 눌려고 그랬는데?

나는 이게 편한데?

이러면은 학습을 못 하는 거죠

그래서 이쪽은 변하면 안 됩니다

이쪽은 말 그대로 목표기 때문에 딱 고정이 돼 있어요

얘는 고정해 놓고 얘를 나의 기대를 수정을 해줘야 되는 거죠

그래서 고정을 하는 거다

그래서 우리가 Td타겟에 맞추는 게 목적이기 때문에 목표를 바꾸면 안 된다


## 폴리악 평균

사실 문제가 한두 가지가 있겠습니까 많은 여러 가지 문제 중에 목표 망이 고정이 돼 있다가 갑자기 한꺼번에 수정이 되는 게 문제입니다

그래서 Q를 두 개로 분리한 것까지는 좋았는데 분리를 해 놨더니 얘랑 얘랑 계속 다르다가 갑자기 같아지는 그런 게 문제에요

그래서 폴리아 평균은 어떠냐면 아니 그렇게 갑자기 바꾸지 말고 조금씩 바꿔 목표 망을 점진적으로 수정을 하겠다

이런 거죠

근데 이제 꼭 해야 되는 건 아니다

이런 얘기고 그 다음에 이제 써주신 것들이 여러 가지가 있는데 새로운 문제로 써 주신 것 중에 최대화편향 얘기를 하셨는데 최대화편향은 Q가 두 개든 하나는 무조건 생기는 겁니다

왜냐하면은 맥스를 하기 때문에 생기는 문제라서 Q가 두 개인 거는 문제가 안 돼요 R 플러스 맥스 그러니까 이제 최대화편향은 이 맥스 때문에 생기는 거거든요

최대화편향 문제는 아니다

그 다음에 이제 Q의 괴리 일정 방향마다 초기화 이거는 맞게 쓰신 거죠

폴리아 평균 얘기해 주시면 맞는 거고 그 다음에 

## 이중 DQN


그다음에 Q학습의 최대한 편향은 우리가 이중 Q학습 할 때 얘기를 했는데 최대한 편향이 생기는 이유는 다시 공식을 보시면 여기 MAX Q' 내가 다음 상태는 최선을 다할 거야

여러분 다이어트를 하시는데 내일부터 열심히 해야지 이렇게 생각한단 말이에요

그러면 여러분이 내일부터 열심히 해야지라고 생각을 하는 이상 항상 어떻게 됩니까?

나의 Q값은?

나 다이어트 성공할 것 같은데?

일단 오늘은 많이 먹지만 내일부터 열심히 할 거니까 80kg 빼는 거 뭐 어렵나?

채소 먹고 운동하면 되는 거 아니야

언제부터 하냐고?

그건 내일부터 하지 내일부터 최선을 다할 거야

그럼 여러분 Q값이 굉장히 과장되어 있을 거란 말이에요

여러분 다이어트 실패할 겁니다

왜냐하면 내일 최선을 안 할 거니까 내일부터 최선을 한다는 생각이 여러분 착각이잖아요

그래서 이 두 개의 Q를 원래부터 DQ에는 분리가 돼 있어요

원래 분리가 돼 있는데 여기서 한 번 더 꺾어주는 거죠

MAX Q를 하지 않고 일단 이 빨간 Q를 가지고 계획을 세웁니다

내일부터 최선을 다할 거야

그러면 파란 Q가 얘기를 해주는 거죠

말 같지도 않습니다

네가 뭐 내일부터 최선을 다해 너 내일 또 안 움직이고 또 치킨을 시켜 먹을 거잖아

그러면 점수를 확 깎는 거죠

그러면 내가 살 뺄 수 있을까 생각을 해보면 냉정하게 못 뺀다는 결론이 나와야 되는 거죠

이해되십니까?

그래서 이중 DQN이 이제 최대한 편향인 건 뭐냐면 항상 다음번에 최선을 다할 거라는 그 생각이 잘못이다

이거예요

MAX Q가 될 거다

그게 잘못이니까 일단 다음번에 뭐가 제일 MAX인지 행동을 일단 뽑은 다음에 평가를 별도로 하는 거예요

그러면 냉정하게 평가할 수 있겠죠

이 두 개 Q가 다르니까 

## 듀얼링

그 다음에 강학습에서 이득이라는 건 뭐냐면 이득은 간단합니다

이득은 어디 갔습니까?

이게 Q가 행동 가치고 V가 상태 가치인데 두 개를 빼면 이득이에요

그래서 내 상태 가치라는 거는 사실 Q들을 다 더한 거 평균이랑 똑같단 말이에요

그래서 평균적인 내가 어떤 이런 행동도 할 수 있고 저런 행동도 할 수 있는데 그러면 그걸 다 뭉뚱그리면 이 정도가 내 상태 가치인데 그거에 비해서 이 행동을 하는 게 얼마나 이득이냐

이런 얘기를 하는 거고 예를 들면 여러분들이 점심이면 도시락 나오니까 그렇고 저녁에 치킨을 시켜 먹어도 배가 부르고 피자를 시켜 먹어도 배가 부른데 그러면 내가 배가...

되게 이상한 예의를 드는 사람들 있잖아

항상 애들이 또 피자야?

피자 맛없어?

나 피자 싫어?

그럼 북한 사람들은 밥을 굶어 이 자식아 이러면 잘못된 거잖아요

왜냐하면 얘는 북한 애가 아니란 말이에요

얘는 피자도 먹을 수 있고 치킨도 먹을 수 있고 돈가스도 먹을 수 있는데 그런 맛있는 것들이 다 먹을 수 있는 상태 있잖아요

그 중에서 피자는 얼마나 더 맛있고 치킨은 얼마나 더 맛있고 돌솥 비빔밥을 먹으면 얼마나 더 맛있고 곤드레 밥을 먹으면 얼마나 더 맛있고 이걸 따져야 되는 거죠 이득이라는 거는 상대적으로 내 상태가 제 비해서 얼마나 크냐 작냐 이거를 말하는 겁니다

그래서 듀얼링을 왜 하냐면 원래는 우리가 Q러닝이기 때문에 Q를 학습을 하는데 Q만 학습을 하면 이 Q는 행동에 따라 달라진단 말이에요

Q가 S랑 A가 들어가는데 내 행동에 따라 달라지기 때문에 행동을 0번을 하면 왼쪽에 반영이 되고 1번을 하면 오른쪽에 반영이 되는데 사실 행동이라는 게 내가 이쪽 행동을 해도 이쪽에 사실 배우는 게 있단 말이에요

사람은 그걸 어떻게 구현할까 생각을 해보니까 이득의 정의를 잘 보니까 Q를 이쪽으로 넘기면 Q는 V 플러스 A네 근데 Q가 달라져도 V는 똑같은 거죠

예를 들면 아까 불평하는 애가 돈가스도 먹어보고 돈가스의 행동 가치가 나오겠죠

피자도 먹어보고 피자도 행동 가치가 나오겠죠

근데 얘의 상태가 지금 똑같단 말이에요

얘는 나만의 잘 먹고 잘 사는 애잖아요

그 상태는 변하지 않는단 말이에요

그래서 이렇게 두 개로 분해를 해놓으면 상태가치랑 이득의 합으로 해놓으면 이게 Q가 되기 때문에 행동을 하나 하면 양쪽으로 반영이 됩니다

V에도 반영이 되고 A에도 반영이 되고 그럼 다른 Q가 있을 때 다른 Q도 이 V랑 이 A의 합이니까 이쪽에 뭔가 학습된 부분이 이 Q의 가치를 반영하는, 평가하는 데 도움이 된다

그래서 이 논리가 듀얼링의 논리가 됩니다

그래서 이제 DQN이 이게 들어가면 이중 DQN, 더블 DQN이라고 하고 이게 들어가면 듀얼링 DQN이라고 하고 둘 다 들어가면 듀얼링 더블 DQN 뭐 이런 식으로 얘기를 합니다


## 퀴즈

<iframe src="https://tally.so/embed/wMYXP8?alignLeft=1&hideTitle=1&transparentBackground=1&dynamicHeight=1" loading="lazy" width="100%" height="1800" frameborder="0" marginheight="0" marginwidth="0" title="[RL] 가치기반 강화학습"></iframe>