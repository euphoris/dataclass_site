
# 리스트와 딕셔너리


## 리스트(List)란?

* **정의**: 순서가 있는 값들의 **변경 가능한(mutable)** 모임
* **특징**:
    * 다양한 데이터 타입(숫자, 문자열, 다른 리스트 등) 함께 저장 가능
    * 요소들이 순서대로 저장되며, 이 순서 유지
    * 요소의 추가, 삭제, 수정 자유
* **예시**: `my_list = [1, "hello", 3.14, True, [10, 20]]`



## 리스트 생성 방법

* **대괄호 `[]` 사용**: 가장 일반적인 방법
    * `empty_list = []` *(빈 리스트)*
    * `numbers = [1, 2, 3, 4, 5]`
    * `mixed_list = [10, "Python", 3.0]`
* **`list()` 함수 사용**: 다른 순회 가능한(iterable) 객체(예: 문자열, 튜플, `range`)를 리스트로 변환
    * `string_to_list = list("hello")`  ➡️  `['h', 'e', 'l', 'l', 'o']`
    * `range_to_list = list(range(5))`  ➡️  `[0, 1, 2, 3, 4]`
    * `tuple_to_list = list((1, 2, 3))`  ➡️  `[1, 2, 3]`
* **빈 리스트 만들기**:
    * `my_list1 = []`
    * `my_list2 = list()`



## 리스트 인덱싱(Indexing)

* **정의**: 리스트 내 특정 위치(인덱스)의 요소에 접근하는 방법
* **인덱스 규칙**:
    * **양수 인덱스**: 맨 앞 요소부터 `0`으로 시작, `1`, `2`, ... 순으로 증가
    * **음수 인덱스**: 맨 뒤 요소부터 `-1`로 시작, `-2`, `-3`, ... 순으로 감소
* **사용법**: `리스트이름[인덱스]`
* **예시**:
    ```python
    fruits = ["사과", "바나나", "딸기", "포도", "오렌지"]
    print(fruits[0])      # 결과: "사과" (첫 번째 요소)
    print(fruits[2])      # 결과: "딸기" (세 번째 요소)
    print(fruits[-1])     # 결과: "오렌지" (마지막 요소)
    print(fruits[-3])     # 결과: "딸기" (뒤에서 세 번째 요소)
    # fruits[5]           # IndexError: list index out of range (존재하지 않는 인덱스 접근 시 오류)
    ```



## 리스트 슬라이싱(Slicing)

* **정의**: 리스트의 특정 범위의 여러 요소를 새로운 리스트로 잘라내어 접근하는 방법
* **사용법**: `리스트이름[start:stop:step]`
    * `start`: 슬라이싱 시작 인덱스 (포함). 생략 시 처음부터.
    * `stop`: 슬라이싱 종료 인덱스 (미포함). 생략 시 끝까지.
    * `step`: 인덱스 증가 간격. 생략 시 `1`.
* **예시**:
    ```python
    numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    print(numbers[2:5])     # 결과: [2, 3, 4] (인덱스 2부터 4까지)
    print(numbers[:3])      # 결과: [0, 1, 2] (처음부터 인덱스 2까지)
    print(numbers[7:])      # 결과: [7, 8, 9] (인덱스 7부터 끝까지)
    print(numbers[1:7:2])   # 결과: [1, 3, 5] (인덱스 1부터 6까지, 2씩 증가)
    print(numbers[:])       # 결과: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] (전체 복사)
    print(numbers[::-1])    # 결과: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] (역순으로)
    ```



## 리스트에 새 요소 추가

* **`append(요소)`**: 리스트의 **맨 뒤에** 새로운 요소 추가
    * 원본 리스트 직접 변경
    * **예시**:
        ```python
        my_list = [1, 2, 3]
        my_list.append(4)
        print(my_list)  # 결과: [1, 2, 3, 4]
        my_list.append([5, 6])
        print(my_list)  # 결과: [1, 2, 3, 4, [5, 6]] (리스트 자체가 요소로 추가)
        ```
* **`insert(인덱스, 요소)`**: 리스트의 **특정 인덱스 위치에** 새로운 요소 추가
    * 기존 요소들은 뒤로 밀림
    * 원본 리스트 직접 변경
    * **예시**:
        ```python
        my_list = ["사과", "딸기", "포도"]
        my_list.insert(1, "바나나") # 인덱스 1 위치에 "바나나" 추가
        print(my_list)  # 결과: ["사과", "바나나", "딸기", "포도"]
        my_list.insert(0, "수박")  # 맨 앞에 추가
        print(my_list)  # 결과: ["수박", "사과", "바나나", "딸기", "포도"]
        ```



## 리스트에서 요소 삭제

* **`remove(값)`**: 리스트에서 **지정된 값과 일치하는 첫 번째 요소 삭제**
    * 해당 값 없으면 `ValueError` 발생
    * 원본 리스트 직접 변경
    * **예시**:
        ```python
        my_list = [10, 20, 30, 20, 40]
        my_list.remove(20) # 첫 번째 20 삭제
        print(my_list)  # 결과: [10, 30, 20, 40]
        # my_list.remove(50) # ValueError: list.remove(x): x not in list
        ```
* **`pop(인덱스)`**: 리스트의 **특정 인덱스 위치의 요소를 삭제하고 그 요소 반환**
    * 인덱스 생략 시 맨 마지막 요소 삭제 및 반환
    * 원본 리스트 직접 변경
    * **예시**:
        ```python
        my_list = ["a", "b", "c", "d", "e"]
        removed_element = my_list.pop(2) # 인덱스 2의 "c" 삭제 및 반환
        print(my_list)          # 결과: ["a", "b", "d", "e"]
        print(removed_element)  # 결과: "c"
        last_element = my_list.pop() # 마지막 요소 "e" 삭제 및 반환
        print(my_list)          # 결과: ["a", "b", "d"]
        print(last_element)     # 결과: "e"
        ```



## 리스트 순서 바꾸기

* **`sort()`**: 리스트 요소들을 **오름차순으로 정렬** (문자열은 사전 순)
    * `reverse=True` 옵션 시 내림차순 정렬
    * 원본 리스트 직접 변경
    * **예시**:
        ```python
        numbers = [3, 1, 4, 1, 5, 9, 2]
        numbers.sort()
        print(numbers)  # 결과: [1, 1, 2, 3, 4, 5, 9]
        numbers.sort(reverse=True)
        print(numbers)  # 결과: [9, 5, 4, 3, 2, 1, 1]
        ```
* **`reverse()`**: 리스트 요소들의 **순서를 반대로 뒤집음**
    * 원본 리스트 직접 변경
    * **예시**:
        ```python
        my_list = [1, "two", 3.0]
        my_list.reverse()
        print(my_list)  # 결과: [3.0, "two", 1]
        ```


## 리스트 길이와 개수 세기

* **`len(리스트)`**: 리스트에 포함된 **요소의 개수(길이) 반환** (내장 함수)
    * **예시**:
        ```python
        my_list = [10, 20, 30]
        print(len(my_list)) # 결과: 3
        ```
* **`count(값)`**: 리스트에서 **특정 값이 몇 개 있는지 개수 반환**
    * **예시**:
        ```python
        numbers = [1, 2, 2, 3, 2, 4]
        print(numbers.count(2)) # 결과: 3
        ```



## 딕셔너리(Dictionary)

* **정의**: **키(Key)**와 **값(Value)**을 하나의 쌍으로 묶어 저장하는 자료구조
* **특징**:
    * **키(Key)**: 고유, 변경 불가능한(immutable) 자료형만 사용 가능 (예: 문자열, 숫자, 튜플)
    * **값(Value)**: 어떤 데이터 타입이든 가능, 중복 가능
    * Python 3.6 이하에서는 요소들의 순서 보장 안 되었으나 **3.7**부터 입력된 순서 유지
    * **변경 가능(mutable)**: 키-값 쌍의 추가, 수정, 삭제 가능
* **용도**: 의미 있는 이름(키)으로 데이터 관리 시 유용 (예: 사람 정보 - 이름, 나이, 직업)



## 딕셔너리 생성 및 기본 조작 ⚙️

* **딕셔너리 생성**: 중괄호 `{}` 사용, `키: 값` 형태로 쌍 구성
    * `empty_dict = {}`
    * `person = {"name": "홍길동", "age": 30, "city": "서울"}`
    * `scores = {101: 85, 102: 92, 103: 78}`
* **값 접근 (Key 사용)**: `딕셔너리이름[키]`
    * `print(person["name"])`  ➡️  `"홍길동"`
    * `print(scores[102])`   ➡️  `92`
    * 존재하지 않는 키로 접근 시 `KeyError` 발생. `get()` 메소드 사용 권장.
        * `print(person.get("job"))` ➡️ `None` (키 없으면 `None` 반환)
        * `print(person.get("job", "정보 없음"))` ➡️ `"정보 없음"` (기본값 지정 가능)


## 딕셔너리 수정 및 삭제 ️

* **새 Key-Value 쌍 추가**: `딕셔너리이름[새로운키] = 새로운값`
    * `person["job"] = "개발자"`
    * `print(person)`  ➡️  `{'name': '홍길동', 'age': 30, 'city': '서울', 'job': '개발자'}`
* **기존 값 수정**: `딕셔너리이름[기존키] = 수정된값`
    * `person["age"] = 31`
    * `print(person)`  ➡️  `{'name': '홍길동', 'age': 31, 'city': '서울', 'job': '개발자'}`
* **특정 Key-Value 쌍 삭제 (`del`)**: `del 딕셔너리이름[키]`
    * `del person["city"]`
    * `print(person)`  ➡️  `{'name': '홍길동', 'age': 31, 'job': '개발자'}`

