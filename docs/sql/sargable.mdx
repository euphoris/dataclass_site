# 인덱스를 이용한 최적화

## UNIQUE SCAN

*   **`UNIQUE SCAN`**: 유일한 결과를 보장하는 경우

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE LISTING_DT > '1995-01-01' and BIZ_REG_NO = '123-45-67890';
```

*   `BIZ_REG_NO`에는 `UNIQUE INDEX`가 설정되어 있음
*   `UNIQUE SCAN`으로 `ROWID`(행 위치)를 찾은 다음, 조건에 맞는 행을 `Filter`
*   `WHERE`에서 순서를 바꿔도 동일하게 최적화됨

## FULL SCAN

*   인덱스 전체를 순서대로 스캔
*   회사 이름 순으로 정렬: 인덱스에 회사 이름이 정렬되어 있으므로 `FULL SCAN`

```sql
SELECT * FROM TB_COMPANY_MASTER ORDER BY COMPANY_NM;
```

*   테이블 전체를 보는 경우 회사 이름 순이 아니므로 인덱스를 `FULL SCAN`하지 않음

```sql
SELECT * FROM TB_COMPANY_MASTER;
```

## FAST FULL SCAN

*   테이블을 스캔하는 것보다 인덱스를 스캔하는 것이 더 빠를 때, 순서 없이 스캔

```sql
SELECT BIZ_REG_NO, COMPANY_NM FROM TB_COMPANY_MASTER;
```

*   `BIZ_REG_NO`와 `COMPANY_NM`을 각각 인덱스에서 `FAST FULL SCAN`한 후 `JOIN`

## RANGE SCAN

*   일정 범위를 인덱스에서 스캔
*   1980년부터 2000년 사이

```sql
SELECT * FROM TB_COMPANY_MASTER
WHERE ESTABLISH_DT BETWEEN TO_DATE('1980', 'YYYY') AND TO_DATE('2000', 'YYYY');
```

*   회사 이름이 "(주)"로 시작하는 경우

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE COMPANY_NM LIKE '(주)%';
```

*   회사 이름이 "자"로 끝나는 경우는 `RANGE SCAN`을 안함(사전순으로 정렬되어 있으므로)

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE COMPANY_NM LIKE '%자';
```

## SKIP SCAN

*   여러 개의 컬럼으로 이뤄진 `COMPOSITE` 인덱스에서 두 번째 이후 컬럼으로 검색할 때
*   첫번째 컬럼 → 두번째 컬럼 순으로 정렬되어 있으므로 건너 뛰면서(`SKIP`) 스캔
*   `FS_TYPE`과 `FS_YM`이 하나의 인덱스로 되어 있으므로 특정 `FS_YM`을 찾으면 `SKIP` 스캔 실행

```sql
SELECT * FROM TB_FINANCIAL_STATEMENT WHERE FS_YM = '202312';
```

*   특정 `FS_TYPE`을 찾는 경우에는 `RANGE` 스캔

```sql
SELECT * FROM TB_FINANCIAL_STATEMENT WHERE FS_TYPE = 'ANNUAL';
```

## SARGABLE

*   `Search Argument Able`의 줄임말로 인덱스를 효과적으로 사용할 수 있는 형태
    *   흔히 "인덱스를 탄다"고 표현
*   **Sargable 연산자**: `=`, `>`, `<`, `>=`, `<=`, `BETWEEN`, `LIKE`, `IS [NOT] NULL`, `IN`
    *   인덱스의 특정 범위로 한정하는 경우
*   회사 이름이 흑풍 그룹과 같은 경우(sargable)

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE COMPANY_NM = '흑풍그룹';
```

*   회사 이름이 흑풍 그룹과 다른 경우(not sargable)

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE COMPANY_NM <> '흑풍그룹';
```

## 컬럼에 계산

*   비교할 컬럼에 계산이나 함수를 적용할 경우 `not sargable`

```sql
SELECT * FROM TB_FINANCIAL_STATEMENT WHERE TOTAL_ASSETS * 1.1 > 1000000000000;
```

*   비교할 값에 계산을 할 경우 `sargable`

```sql
SELECT * FROM TB_FINANCIAL_STATEMENT WHERE TOTAL_ASSETS > 1000000000000 / 1.1;
```

*   설립일자에서 연도만 뽑아서 2000과 비교하는 경우 `not sargable`

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE TO_CHAR(ESTABLISH_DT, 'YYYY') < '2000';
```

*   2000을 날짜로 바꿔서 설립 일자와 비교 `sargable`

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE ESTABLISH_DT < TO_DATE('2000', 'YYYY');
```

## 함수 기반 인덱스

*   함수 기반 인덱스가 설정된 경우에는 함수를 적용해도 `sargable`

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE UPPER(COMPANY_ENG_NM) < 'E';
```

*   인덱스에 적용된 함수 보는 방법

```sql
SELECT INDEX_NAME, COLUMN_EXPRESSION
FROM ALL_IND_EXPRESSIONS
WHERE INDEX_NAME = 'IDX_COMPANY_COMPANY_ENG_NM_UPPER';
```

*   함수 기반 인덱스가 설정되어 있지 않으면 `not sargable`

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE LOWER(COMPANY_ENG_NM) < 'e';
```

## UNION을 이용해 인덱스 사용하기

*   `OR`로 검색을 할 경우 인덱스를 사용하지 못할 수 있음

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE COMPANY_NM LIKE '(주)%' OR ESTABLISH_DT > '2000-01-01';
```

*   각각 인덱스를 이용해 검색을 하도록 질의한 후, 그 결과를 `UNION`이나 `UNION ALL`을 이용하여 합칠 수 있음
    *   단, 여러 번 검색으로 총 검색 비용은 더 높을 수도 있으므로 실행 계획을 비교해볼 것

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE COMPANY_NM LIKE '(주)%'
UNION
SELECT * FROM TB_COMPANY_MASTER WHERE ESTABLISH_DT > '2000-01-01';
```

## 퀴즈

import { QuizComponent } from "@/components/QuizComponent";

<QuizComponent quizId="sargable" quizItems={
[
  {
    "item_type": "radio",
    "question": "PRIMARY KEY (PK)나 UNIQUE 제약조건이 걸린 컬럼을 '=' 조건으로 조회하면 유일한 결과를 보장합니다. 이때 인덱스를 스캔하는 방식은 무엇인가요?",
    "options": [
      "FULL SCAN",
      "RANGE SCAN",
      "UNIQUE SCAN",
      "SKIP SCAN"
    ],
    "hint": "결과가 유일(unique)합니다.",
    "solution": "UNIQUE SCAN"
  },
  {
    "item_type": "radio",
    "question": "`SELECT * FROM TB_COMPANY_MASTER WHERE COMPANY_NM LIKE '(주)%'` 쿼리에서 사용될 가능성이 높은 인덱스 스캔 방식은 무엇인가요?",
    "options": [
      "FULL SCAN",
      "RANGE SCAN",
      "FAST FULL SCAN",
      "UNIQUE SCAN"
    ],
    "hint": "인덱스가 사전순으로 정렬되어 있을 때, 특정 '범위'를 검색하는 방식입니다.",
    "solution": "RANGE SCAN"
  },
  {
    "item_type": "radio",
    "question": "여러 컬럼으로 구성된 복합 인덱스(예: (FS_TYPE, FS_YM))에서, 인덱스의 첫 번째 컬럼(FS_TYPE)이 아닌 두 번째 컬럼(FS_YM)을 조건으로 검색할 때 사용되는 스캔 방식은 무엇인가요?",
    "options": [
      "SKIP SCAN",
      "RANGE SCAN",
      "FULL SCAN",
      "TABLE ACCESS (FULL)"
    ],
    "hint": "첫 번째 컬럼의 값들을 '건너뛰면서' 두 번째 컬럼을 탐색하는 방식입니다.",
    "solution": "SKIP SCAN"
  },
  {
    "item_type": "radio",
    "question": "인덱스를 효과적으로 사용할 수 있는 쿼리 형태(일명 '인덱스를 탄다')를 의미하는 용어는 무엇인가요?",
    "options": [
      "Cardinality",
      "Optimizer",
      "Sargable",
      "Statistics"
    ],
    "hint": "'Search Argument Able'의 줄임말입니다.",
    "solution": "Sargable"
  },
  {
    "item_type": "radio",
    "question": "다음 SQL 쿼리 중, `ESTABLISH_DT` 컬럼의 인덱스를 가장 효과적으로 사용할 수 있는(Sargable) 형태는 무엇인가요?",
    "options": [
      "SELECT * FROM TB_COMPANY_MASTER WHERE TO_CHAR(ESTABLISH_DT, 'YYYY') < '2000';",
      "SELECT * FROM TB_COMPANY_MASTER WHERE ESTABLISH_DT < TO_DATE('2000', 'YYYY');",
      "SELECT * FROM TB_COMPANY_MASTER WHERE ESTABLISH_DT || '' < '2000-01-01';",
      "SELECT * FROM TB_COMPANY_MASTER WHERE ESTABLISH_DT + 1 < TO_DATE('2000-01-02', 'YYYY-MM-DD');"
    ],
    "hint": "비교 대상인 *컬럼* 자체에 함수나 계산을 적용하면 인덱스를 사용하기 어렵습니다.",
    "solution": "SELECT * FROM TB_COMPANY_MASTER WHERE ESTABLISH_DT < TO_DATE('2000', 'YYYY');"
  },
  {
    "item_type": "radio",
    "question": "`WHERE UPPER(COMPANY_ENG_NM) = 'APPLE'`과 같이 컬럼에 함수를 적용한 조건문이 인덱스를 사용할 수 있는(Sargable) 경우는 무엇인가요?",
    "options": [
      "해당 컬럼이 PRIMARY KEY일 때",
      "UPPER(COMPANY_ENG_NM)와 동일한 형태의 '함수 기반 인덱스(Function-Based Index)'가 생성되어 있을 때",
      "해당 컬럼이 UNIQUE 제약조건을 가질 때",
      "옵티마이저가 항상 함수를 자동으로 변환해주기 때문에 언제나 가능하다."
    ],
    "hint": "인덱스 자체가 함수 계산 결과를 미리 저장하고 있어야 합니다.",
    "solution": "UPPER(COMPANY_ENG_NM)와 동일한 형태의 '함수 기반 인덱스(Function-Based Index)'가 생성되어 있을 때"
  },
  {
    "item_type": "radio",
    "question": "`OR` 연산자 대신 `UNION`을 사용하여 질의를 작성하면 더 빠른 경우가 있습니다. 왜 그렇습니까?",
    "options": [
      "모든 경우에 UNION이 OR보다 빠르기 때문에",
      "OR로 검색할 경우 인덱스를 사용하지 못할 수 있어, 각각의 조건이 인덱스를 사용하도록 분리한 뒤 UNION으로 합쳤을 때 더 빠를 수 있기 때문에",
      "OR은 두 개의 조건만 비교할 수 있지만 UNION은 세 개 이상의 조건을 합칠 수 있기 때문에",
      "OR은 NULL 값을 처리하지 못하기 때문에"
    ],
    "hint": "OR로 연결된 서로 다른 컬럼의 조건은 옵티마이저가 인덱스를 활용하기 어려울 수 있습니다.",
    "solution": "OR로 검색할 경우 인덱스를 사용하지 못할 수 있어, 각각의 조건이 인덱스를 사용하도록 분리한 뒤 UNION으로 합쳤을 때 더 빠를 수 있기 때문에"
  }
]
} />


## Q&A
<iframe src="https://tally.so/embed/wbOOKg?alignLeft=1&hideTitle=1&transparentBackground=1&dynamicHeight=0" loading="lazy" width="100%" height="274" frameborder="0" marginheight="0" marginwidth="0" title="Q&A"></iframe>