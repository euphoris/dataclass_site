# 인덱스

## SQL 실행 계획

*   SQL Developer에서 SQL 구문에 F10 키를 누르거나 다음 명령을 실행

```sql
EXPLAIN PLAN FOR SELECT * FROM TB_COMPANY_MASTER; -- 실행 계획 생성
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY); -- 실행 계획 보기
```

*   **`OPTIONS`**: 처리 방법(FULL: 테이블 전체를 스캔)
*   **`CARDINALITY`**: 예상되는 실행 결과 행 수 (실제 결과와 크게 다를 경우 질의가 비효율적)
*   **`COST`**: 예상되는 실행 비용 (비용이 높으면 질의가 비효율적)
*   실제 실행은 역순으로 이뤄짐(하위 실행의 결과가 모여서 상위 실행 결과가 됨)

## 옵티마이저(Optimizer)

*   사용자가 입력한 구문을 최적화해주는 부분
*   **비용 기반 옵티마이저**:
    *   수많은 '후보 실행 계획'을 생성 (예: A->B NL Join, B->A Hash Join...)
    *   통계 정보(`Statistics`) 를 바탕으로 각 계획의 비용(`Cost`) 을 추정
    *   가장 비용이 낮은 계획을 최종 선택

## 옵티마이저 작동 예시

*   서브쿼리

```sql
SELECT * FROM
    (SELECT * FROM TB_COMPANY_MASTER WHERE HQ_ADDRESS LIKE '%강남구%')
WHERE LISTING_DT > '1990-01-01';
```

*   실제로는 `AND` 조건으로 결합해서 한 번에 검색

(실행 계획 예시)
`TABLE ACCESS (FULL)`
`Filter Predicates: AND`
 `HQ_ADDRESS LIKE '%강남구%'`
 `LISTING_DT > '1990-01-01'`

## 인덱스(index)

*   추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
*   **장점**
    *   테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있음
    *   전반적인 시스템의 부하를 줄일 수 있음
*   **단점**
    *   인덱스를 관리하기 위해 DB의 저장공간이 필요
    *   데이터 변경 시 인덱스도 변경되어야 하므로 추가 작업이 필요
    *   잘못 사용하면 오히려 성능이 저하
*   인덱스가 있거나 없어도 SQL 문의 실행 결과는 같음(속도만 달라짐)
*   같은 의미면 인덱스를 사용하여 속도를 높일 수 있도록 질의 작성

## 인덱스의 자료 구조

*   **분기(`branch`) 블록**: 검색을 위한 용도
*   **잎(`leaf`) 블록**: 키 값(`rowid`)을 저장

## 인덱스 정보 보기

*   `TB_COMPANY_MASTER`의 인덱스 보기

```sql
SELECT
    INDEX_NAME,    -- 이름
    INDEX_TYPE,    -- 유형
    UNIQUENESS     -- UNIQUE 여부
FROM ALL_INDEXES
WHERE TABLE_NAME = 'TB_COMPANY_MASTER';
```

| INDEX\_NAME | INDEX\_TYPE | UNIQUENESS |
| :--- | :--- | :--- |
| IDX\_COMPANY\_NM | NORMAL | NONUNIQUE |
| IDX\_COMPANY\_EST\_DT | NORMAL | NONUNIQUE |
| IDX\_COMPANY\_COVER\_CAT\_NM | NORMAL | NONUNIQUE |
| IDX\_COMPANY\_CEO\_UPPER | FUNCTION-BASED NORMAL | NONUNIQUE |
| PK\_COMPANY\_MASTER | NORMAL | UNIQUE |
| SYS\_C008505 | NORMAL | UNIQUE |

## 인덱스를 구성하는 컬럼

*   `TB_COMPANY_MASTER`의 인덱스를 구성하는 컬럼 보기

```sql
SELECT
    INDEX_NAME,       -- 인덱스 이름
    COLUMN_NAME,      -- 컬럼 이름
    COLUMN_POSITION   -- 인덱스에서 컬럼의 순서
FROM ALL_IND_COLUMNS
WHERE TABLE_NAME = 'TB_COMPANY_MASTER'
ORDER BY INDEX_NAME, COLUMN_POSITION;
```

| INDEX\_NAME | COLUMN\_NAME | COLUMN\_POSITION |
| :--- | :--- | :--- |
| IDX\_COMPANY\_CEO\_UPPER | SYS\_NC00019$ | 1 |
| IDX\_COMPANY\_COVER\_CAT\_NM | COMPANY\_TYPE\_CAT | 1 |
| IDX\_COMPANY\_COVER\_CAT\_NM | COMPANY\_NM | 2 |
| IDX\_COMPANY\_EST\_DT | ESTABLISH\_DT | 1 |
| IDX\_COMPANY\_NM | COMPANY\_NM | 1 |
| PK\_COMPANY\_MASTER | BIZ\_REG\_NO | 1 |
| SYS\_C008505 | COMPANY\_CD | 1 |

## UNIQUE SCAN

*   **`UNIQUE SCAN`**: 유일한 결과를 보장하는 경우

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE LISTING_DT > '1995-01-01' and BIZ_REG_NO = '123-45-67890';
```

*   `BIZ_REG_NO`에는 `UNIQUE INDEX`가 설정되어 있음
*   `UNIQUE SCAN`으로 `ROWID`(행 위치)를 찾은 다음, 조건에 맞는 행을 `Filter`
*   `WHERE`에서 순서를 바꿔도 동일하게 최적화됨

## FULL SCAN

*   인덱스 전체를 순서대로 스캔
*   회사 이름 순으로 정렬: 인덱스에 회사 이름이 정렬되어 있으므로 `FULL SCAN`

```sql
SELECT * FROM TB_COMPANY_MASTER ORDER BY COMPANY_NM;
```

*   테이블 전체를 보는 경우 회사 이름 순이 아니므로 인덱스를 `FULL SCAN`하지 않음

```sql
SELECT * FROM TB_COMPANY_MASTER;
```

## FAST FULL SCAN

*   테이블을 스캔하는 것보다 인덱스를 스캔하는 것이 더 빠를 때, 순서 없이 스캔

```sql
SELECT BIZ_REG_NO, COMPANY_NM FROM TB_COMPANY_MASTER;
```

*   `BIZ_REG_NO`와 `COMPANY_NM`을 각각 인덱스에서 `FAST FULL SCAN`한 후 `JOIN`

## RANGE SCAN

*   일정 범위를 인덱스에서 스캔
*   1980년부터 2000년 사이

```sql
SELECT * FROM TB_COMPANY_MASTER
WHERE ESTABLISH_DT BETWEEN TO_DATE('1980', 'YYYY') AND TO_DATE('2000', 'YYYY');
```

*   회사 이름이 "(주)"로 시작하는 경우

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE COMPANY_NM LIKE '(주)%';
```

*   회사 이름이 "자"로 끝나는 경우는 `RANGE SCAN`을 안함(사전순으로 정렬되어 있으므로)

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE COMPANY_NM LIKE '%자';
```

## SKIP SCAN

*   여러 개의 컬럼으로 이뤄진 `COMPOSITE` 인덱스에서 두 번째 이후 컬럼으로 검색할 때
*   첫번째 컬럼 → 두번째 컬럼 순으로 정렬되어 있으므로 건너 뛰면서(`SKIP`) 스캔
*   `FS_TYPE`과 `FS_YM`이 하나의 인덱스로 되어 있으므로 특정 `FS_YM`을 찾으면 `SKIP` 스캔 실행

```sql
SELECT * FROM TB_FINANCIAL_STATEMENT WHERE FS_YM = '202312';
```

*   특정 `FS_TYPE`을 찾는 경우에는 `RANGE` 스캔

```sql
SELECT * FROM TB_FINANCIAL_STATEMENT WHERE FS_TYPE = 'ANNUAL';
```

## SARGABLE

*   `Search Argument Able`의 줄임말로 인덱스를 효과적으로 사용할 수 있는 형태
    *   흔히 "인덱스를 탄다"고 표현
*   **Sargable 연산자**: `=`, `>`, `<`, `>=`, `<=`, `BETWEEN`, `LIKE`, `IS [NOT] NULL`, `IN`
    *   인덱스의 특정 범위로 한정하는 경우
*   회사 이름이 흑풍 그룹과 같은 경우(sargable)

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE COMPANY_NM = '흑풍그룹';
```

*   회사 이름이 흑풍 그룹과 다른 경우(not sargable)

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE COMPANY_NM <> '흑풍그룹';
```

## 컬럼에 계산

*   비교할 컬럼에 계산이나 함수를 적용할 경우 `not sargable`

```sql
SELECT * FROM TB_FINANCIAL_STATEMENT WHERE TOTAL_ASSETS * 1.1 > 1000000000000;
```

*   비교할 값에 계산을 할 경우 `sargable`

```sql
SELECT * FROM TB_FINANCIAL_STATEMENT WHERE TOTAL_ASSETS > 1000000000000 / 1.1;
```

*   설립일자에서 연도만 뽑아서 2000과 비교하는 경우 `not sargable`

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE TO_CHAR(ESTABLISH_DT, 'YYYY') < '2000';
```

*   2000을 날짜로 바꿔서 설립 일자와 비교 `sargable`

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE ESTABLISH_DT < TO_DATE('2000', 'YYYY');
```

## 함수 기반 인덱스

*   함수 기반 인덱스가 설정된 경우에는 함수를 적용해도 `sargable`

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE UPPER(COMPANY_ENG_NM) < 'E';
```

*   인덱스에 적용된 함수 보는 방법

```sql
SELECT INDEX_NAME, COLUMN_EXPRESSION
FROM ALL_IND_EXPRESSIONS
WHERE INDEX_NAME = 'IDX_COMPANY_COMPANY_ENG_NM_UPPER';
```

*   함수 기반 인덱스가 설정되어 있지 않으면 `not sargable`

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE LOWER(COMPANY_ENG_NM) < 'e';
```

## UNION을 이용해 인덱스 사용하기

*   `OR`로 검색을 할 경우 인덱스를 사용하지 못할 수 있음

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE COMPANY_NM LIKE '(주)%' OR ESTABLISH_DT > '2000-01-01';
```

*   각각 인덱스를 이용해 검색을 하도록 질의한 후, 그 결과를 `UNION`이나 `UNION ALL`을 이용하여 합칠 수 있음
    *   단, 여러 번 검색으로 총 검색 비용은 더 높을 수도 있으므로 실행 계획을 비교해볼 것

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE COMPANY_NM LIKE '(주)%'
UNION
SELECT * FROM TB_COMPANY_MASTER WHERE ESTABLISH_DT > '2000-01-01';
```