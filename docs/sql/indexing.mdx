# 인덱스

## SQL 실행 계획

*   SQL Developer에서 SQL 구문에 F10 키를 누르거나 다음 명령을 실행

```sql
EXPLAIN PLAN FOR SELECT * FROM TB_COMPANY_MASTER; -- 실행 계획 생성
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY); -- 실행 계획 보기
```

*   **`OPTIONS`**: 처리 방법(FULL: 테이블 전체를 스캔)
*   **`CARDINALITY`**: 예상되는 실행 결과 행 수 (실제 결과와 크게 다를 경우 질의가 비효율적)
*   **`COST`**: 예상되는 실행 비용 (비용이 높으면 질의가 비효율적)
*   실제 실행은 역순으로 이뤄짐(하위 실행의 결과가 모여서 상위 실행 결과가 됨)

## 옵티마이저(Optimizer)

*   사용자가 입력한 구문을 최적화해주는 부분
*   **비용 기반 옵티마이저**:
    *   수많은 '후보 실행 계획'을 생성 (예: A->B NL Join, B->A Hash Join...)
    *   통계 정보(`Statistics`) 를 바탕으로 각 계획의 비용(`Cost`) 을 추정
    *   가장 비용이 낮은 계획을 최종 선택

## 옵티마이저 작동 예시

*   서브쿼리

```sql
SELECT * FROM
    (SELECT * FROM TB_COMPANY_MASTER WHERE HQ_ADDRESS LIKE '%강남구%')
WHERE LISTING_DT > '1990-01-01';
```

*   실제로는 `AND` 조건으로 결합해서 한 번에 검색

(실행 계획 예시)
`TABLE ACCESS (FULL)`
`Filter Predicates: AND`
 `HQ_ADDRESS LIKE '%강남구%'`
 `LISTING_DT > '1990-01-01'`

## 인덱스(index)

*   추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
*   **장점**
    *   테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있음
    *   전반적인 시스템의 부하를 줄일 수 있음
*   **단점**
    *   인덱스를 관리하기 위해 DB의 저장공간이 필요
    *   데이터 변경 시 인덱스도 변경되어야 하므로 추가 작업이 필요
    *   잘못 사용하면 오히려 성능이 저하
*   인덱스가 있거나 없어도 SQL 문의 실행 결과는 같음(속도만 달라짐)
*   같은 의미면 인덱스를 사용하여 속도를 높일 수 있도록 질의 작성

## 인덱스의 자료 구조

*   **분기(`branch`) 블록**: 검색을 위한 용도
*   **잎(`leaf`) 블록**: 키 값(`rowid`)을 저장

## 인덱스 정보 보기

*   `TB_COMPANY_MASTER`의 인덱스 보기

```sql
SELECT
    INDEX_NAME,    -- 이름
    INDEX_TYPE,    -- 유형
    UNIQUENESS     -- UNIQUE 여부
FROM ALL_INDEXES
WHERE TABLE_NAME = 'TB_COMPANY_MASTER';
```

| INDEX\_NAME | INDEX\_TYPE | UNIQUENESS |
| :--- | :--- | :--- |
| IDX\_COMPANY\_NM | NORMAL | NONUNIQUE |
| IDX\_COMPANY\_EST\_DT | NORMAL | NONUNIQUE |
| IDX\_COMPANY\_COVER\_CAT\_NM | NORMAL | NONUNIQUE |
| IDX\_COMPANY\_CEO\_UPPER | FUNCTION-BASED NORMAL | NONUNIQUE |
| PK\_COMPANY\_MASTER | NORMAL | UNIQUE |
| SYS\_C008505 | NORMAL | UNIQUE |

## 인덱스를 구성하는 컬럼

*   `TB_COMPANY_MASTER`의 인덱스를 구성하는 컬럼 보기

```sql
SELECT
    INDEX_NAME,       -- 인덱스 이름
    COLUMN_NAME,      -- 컬럼 이름
    COLUMN_POSITION   -- 인덱스에서 컬럼의 순서
FROM ALL_IND_COLUMNS
WHERE TABLE_NAME = 'TB_COMPANY_MASTER'
ORDER BY INDEX_NAME, COLUMN_POSITION;
```

| INDEX\_NAME | COLUMN\_NAME | COLUMN\_POSITION |
| :--- | :--- | :--- |
| IDX\_COMPANY\_CEO\_UPPER | SYS\_NC00019$ | 1 |
| IDX\_COMPANY\_COVER\_CAT\_NM | COMPANY\_TYPE\_CAT | 1 |
| IDX\_COMPANY\_COVER\_CAT\_NM | COMPANY\_NM | 2 |
| IDX\_COMPANY\_EST\_DT | ESTABLISH\_DT | 1 |
| IDX\_COMPANY\_NM | COMPANY\_NM | 1 |
| PK\_COMPANY\_MASTER | BIZ\_REG\_NO | 1 |
| SYS\_C008505 | COMPANY\_CD | 1 |

## UNIQUE SCAN

*   **`UNIQUE SCAN`**: 유일한 결과를 보장하는 경우

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE LISTING_DT > '1995-01-01' and BIZ_REG_NO = '123-45-67890';
```

*   `BIZ_REG_NO`에는 `UNIQUE INDEX`가 설정되어 있음
*   `UNIQUE SCAN`으로 `ROWID`(행 위치)를 찾은 다음, 조건에 맞는 행을 `Filter`
*   `WHERE`에서 순서를 바꿔도 동일하게 최적화됨

## FULL SCAN

*   인덱스 전체를 순서대로 스캔
*   회사 이름 순으로 정렬: 인덱스에 회사 이름이 정렬되어 있으므로 `FULL SCAN`

```sql
SELECT * FROM TB_COMPANY_MASTER ORDER BY COMPANY_NM;
```

*   테이블 전체를 보는 경우 회사 이름 순이 아니므로 인덱스를 `FULL SCAN`하지 않음

```sql
SELECT * FROM TB_COMPANY_MASTER;
```

## FAST FULL SCAN

*   테이블을 스캔하는 것보다 인덱스를 스캔하는 것이 더 빠를 때, 순서 없이 스캔

```sql
SELECT BIZ_REG_NO, COMPANY_NM FROM TB_COMPANY_MASTER;
```

*   `BIZ_REG_NO`와 `COMPANY_NM`을 각각 인덱스에서 `FAST FULL SCAN`한 후 `JOIN`

## RANGE SCAN

*   일정 범위를 인덱스에서 스캔
*   1980년부터 2000년 사이

```sql
SELECT * FROM TB_COMPANY_MASTER
WHERE ESTABLISH_DT BETWEEN TO_DATE('1980', 'YYYY') AND TO_DATE('2000', 'YYYY');
```

*   회사 이름이 "(주)"로 시작하는 경우

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE COMPANY_NM LIKE '(주)%';
```

*   회사 이름이 "자"로 끝나는 경우는 `RANGE SCAN`을 안함(사전순으로 정렬되어 있으므로)

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE COMPANY_NM LIKE '%자';
```

## SKIP SCAN

*   여러 개의 컬럼으로 이뤄진 `COMPOSITE` 인덱스에서 두 번째 이후 컬럼으로 검색할 때
*   첫번째 컬럼 → 두번째 컬럼 순으로 정렬되어 있으므로 건너 뛰면서(`SKIP`) 스캔
*   `FS_TYPE`과 `FS_YM`이 하나의 인덱스로 되어 있으므로 특정 `FS_YM`을 찾으면 `SKIP` 스캔 실행

```sql
SELECT * FROM TB_FINANCIAL_STATEMENT WHERE FS_YM = '202312';
```

*   특정 `FS_TYPE`을 찾는 경우에는 `RANGE` 스캔

```sql
SELECT * FROM TB_FINANCIAL_STATEMENT WHERE FS_TYPE = 'ANNUAL';
```

## SARGABLE

*   `Search Argument Able`의 줄임말로 인덱스를 효과적으로 사용할 수 있는 형태
    *   흔히 "인덱스를 탄다"고 표현
*   **Sargable 연산자**: `=`, `>`, `<`, `>=`, `<=`, `BETWEEN`, `LIKE`, `IS [NOT] NULL`, `IN`
    *   인덱스의 특정 범위로 한정하는 경우
*   회사 이름이 흑풍 그룹과 같은 경우(sargable)

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE COMPANY_NM = '흑풍그룹';
```

*   회사 이름이 흑풍 그룹과 다른 경우(not sargable)

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE COMPANY_NM <> '흑풍그룹';
```

## 컬럼에 계산

*   비교할 컬럼에 계산이나 함수를 적용할 경우 `not sargable`

```sql
SELECT * FROM TB_FINANCIAL_STATEMENT WHERE TOTAL_ASSETS * 1.1 > 1000000000000;
```

*   비교할 값에 계산을 할 경우 `sargable`

```sql
SELECT * FROM TB_FINANCIAL_STATEMENT WHERE TOTAL_ASSETS > 1000000000000 / 1.1;
```

*   설립일자에서 연도만 뽑아서 2000과 비교하는 경우 `not sargable`

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE TO_CHAR(ESTABLISH_DT, 'YYYY') < '2000';
```

*   2000을 날짜로 바꿔서 설립 일자와 비교 `sargable`

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE ESTABLISH_DT < TO_DATE('2000', 'YYYY');
```

## 함수 기반 인덱스

*   함수 기반 인덱스가 설정된 경우에는 함수를 적용해도 `sargable`

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE UPPER(COMPANY_ENG_NM) < 'E';
```

*   인덱스에 적용된 함수 보는 방법

```sql
SELECT INDEX_NAME, COLUMN_EXPRESSION
FROM ALL_IND_EXPRESSIONS
WHERE INDEX_NAME = 'IDX_COMPANY_COMPANY_ENG_NM_UPPER';
```

*   함수 기반 인덱스가 설정되어 있지 않으면 `not sargable`

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE LOWER(COMPANY_ENG_NM) < 'e';
```

## UNION을 이용해 인덱스 사용하기

*   `OR`로 검색을 할 경우 인덱스를 사용하지 못할 수 있음

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE COMPANY_NM LIKE '(주)%' OR ESTABLISH_DT > '2000-01-01';
```

*   각각 인덱스를 이용해 검색을 하도록 질의한 후, 그 결과를 `UNION`이나 `UNION ALL`을 이용하여 합칠 수 있음
    *   단, 여러 번 검색으로 총 검색 비용은 더 높을 수도 있으므로 실행 계획을 비교해볼 것

```sql
SELECT * FROM TB_COMPANY_MASTER WHERE COMPANY_NM LIKE '(주)%'
UNION
SELECT * FROM TB_COMPANY_MASTER WHERE ESTABLISH_DT > '2000-01-01';
```

## 퀴즈

import { QuizComponent } from "@/components/QuizComponent";

<QuizComponent quizId="indexing" quizItems={
    [
  {
    "item_type": "radio",
    "question": "SQL 실행 계획(Execution Plan)에서 `CARDINALITY` 항목이 의미하는 것은 무엇인가요?",
    "options": [
      "SQL 구문의 실행 순서",
      "예상되는 실행 비용",
      "예상되는 실행 결과 행 수",
      "쿼리 처리에 사용된 연산자(OPTIONS)"
    ],
    "hint": "이 값이 실제 결과와 크게 다를 경우 질의가 비효율적일 수 있습니다.",
    "solution": "예상되는 실행 결과 행 수"
  },
  {
    "item_type": "radio",
    "question": "비용 기반 옵티마이저(Cost-Based Optimizer)가 최종 실행 계획을 선택하는 기준은 무엇인가요?",
    "options": [
      "가장 많은 인덱스를 사용하는 계획",
      "통계 정보를 바탕으로 추정한 비용(Cost)이 가장 낮은 계획",
      "사용자가 작성한 SQL 구문 순서와 가장 유사한 계획",
      "가장 적은 수의 조인을 사용하는 계획"
    ],
    "hint": "여러 '후보 실행 계획'을 생성하고 통계 정보를 바탕으로 각 계획의 '비용'을 추정합니다.",
    "solution": "통계 정보를 바탕으로 추정한 비용(Cost)이 가장 낮은 계획"
  },
  {
    "item_type": "checkbox",
    "question": "인덱스(Index)의 단점에 대한 설명으로 옳은 것을 모두 고르세요.",
    "options": [
      "테이블 조회 속도를 향상시킨다.",
      "인덱스 관리를 위한 추가 저장 공간이 필요하다.",
      "데이터가 변경(INSERT, UPDATE, DELETE)될 때 인덱스도 변경되어야 하므로 추가 작업이 필요하다.",
      "잘못 사용하면 오히려 성능이 저하될 수 있다."
    ],
    "hint": "인덱스는 검색 속도를 높이는 대신 유지 관리에 비용이 듭니다.",
    "solution": [
      "인덱스 관리를 위한 추가 저장 공간이 필요하다.",
      "데이터가 변경(INSERT, UPDATE, DELETE)될 때 인덱스도 변경되어야 하므로 추가 작업이 필요하다.",
      "잘못 사용하면 오히려 성능이 저하될 수 있다."
    ]
  },
  {
    "item_type": "radio",
    "question": "PRIMARY KEY (PK)나 UNIQUE 제약조건이 걸린 컬럼을 '=' 조건으로 조회하면 유일한 결과를 보장합니다. 이때 인덱스를 스캔하는 방식은 무엇인가요?",
    "options": [
      "FULL SCAN",
      "RANGE SCAN",
      "UNIQUE SCAN",
      "SKIP SCAN"
    ],
    "hint": "결과가 유일(unique)합니다.",
    "solution": "UNIQUE SCAN"
  },
  {
    "item_type": "radio",
    "question": "`SELECT * FROM TB_COMPANY_MASTER WHERE COMPANY_NM LIKE '(주)%'` 쿼리에서 사용될 가능성이 높은 인덱스 스캔 방식은 무엇인가요?",
    "options": [
      "FULL SCAN",
      "RANGE SCAN",
      "FAST FULL SCAN",
      "UNIQUE SCAN"
    ],
    "hint": "인덱스가 사전순으로 정렬되어 있을 때, 특정 '범위'를 검색하는 방식입니다.",
    "solution": "RANGE SCAN"
  },
  {
    "item_type": "radio",
    "question": "여러 컬럼으로 구성된 복합 인덱스(예: (FS_TYPE, FS_YM))에서, 인덱스의 첫 번째 컬럼(FS_TYPE)이 아닌 두 번째 컬럼(FS_YM)을 조건으로 검색할 때 사용되는 스캔 방식은 무엇인가요?",
    "options": [
      "SKIP SCAN",
      "RANGE SCAN",
      "FULL SCAN",
      "TABLE ACCESS (FULL)"
    ],
    "hint": "첫 번째 컬럼의 값들을 '건너뛰면서' 두 번째 컬럼을 탐색하는 방식입니다.",
    "solution": "SKIP SCAN"
  },
  {
    "item_type": "radio",
    "question": "인덱스를 효과적으로 사용할 수 있는 쿼리 형태(일명 '인덱스를 탄다')를 의미하는 용어는 무엇인가요?",
    "options": [
      "Cardinality",
      "Optimizer",
      "Sargable",
      "Statistics"
    ],
    "hint": "'Search Argument Able'의 줄임말입니다.",
    "solution": "Sargable"
  },
  {
    "item_type": "radio",
    "question": "다음 SQL 쿼리 중, `ESTABLISH_DT` 컬럼의 인덱스를 가장 효과적으로 사용할 수 있는(Sargable) 형태는 무엇인가요?",
    "options": [
      "SELECT * FROM TB_COMPANY_MASTER WHERE TO_CHAR(ESTABLISH_DT, 'YYYY') < '2000';",
      "SELECT * FROM TB_COMPANY_MASTER WHERE ESTABLISH_DT < TO_DATE('2000', 'YYYY');",
      "SELECT * FROM TB_COMPANY_MASTER WHERE ESTABLISH_DT || '' < '2000-01-01';",
      "SELECT * FROM TB_COMPANY_MASTER WHERE ESTABLISH_DT + 1 < TO_DATE('2000-01-02', 'YYYY-MM-DD');"
    ],
    "hint": "비교 대상인 *컬럼* 자체에 함수나 계산을 적용하면 인덱스를 사용하기 어렵습니다.",
    "solution": "SELECT * FROM TB_COMPANY_MASTER WHERE ESTABLISH_DT < TO_DATE('2000', 'YYYY');"
  },
  {
    "item_type": "radio",
    "question": "`WHERE UPPER(COMPANY_ENG_NM) = 'APPLE'`과 같이 컬럼에 함수를 적용한 조건문이 인덱스를 사용할 수 있는(Sargable) 경우는 무엇인가요?",
    "options": [
      "해당 컬럼이 PRIMARY KEY일 때",
      "UPPER(COMPANY_ENG_NM)와 동일한 형태의 '함수 기반 인덱스(Function-Based Index)'가 생성되어 있을 때",
      "해당 컬럼이 UNIQUE 제약조건을 가질 때",
      "옵티마이저가 항상 함수를 자동으로 변환해주기 때문에 언제나 가능하다."
    ],
    "hint": "인덱스 자체가 함수 계산 결과를 미리 저장하고 있어야 합니다.",
    "solution": "UPPER(COMPANY_ENG_NM)와 동일한 형태의 '함수 기반 인덱스(Function-Based Index)'가 생성되어 있을 때"
  },
  {
    "item_type": "radio",
    "question": "`OR` 연산자 대신 `UNION`을 사용하여 질의를 작성하면 더 빠른 경우가 있습니다. 왜 그렇습니까?",
    "options": [
      "모든 경우에 UNION이 OR보다 빠르기 때문에",
      "OR로 검색할 경우 인덱스를 사용하지 못할 수 있어, 각각의 조건이 인덱스를 사용하도록 분리한 뒤 UNION으로 합쳤을 때 더 빠를 수 있기 때문에",
      "OR은 두 개의 조건만 비교할 수 있지만 UNION은 세 개 이상의 조건을 합칠 수 있기 때문에",
      "OR은 NULL 값을 처리하지 못하기 때문에"
    ],
    "hint": "OR로 연결된 서로 다른 컬럼의 조건은 옵티마이저가 인덱스를 활용하기 어려울 수 있습니다.",
    "solution": "OR로 검색할 경우 인덱스를 사용하지 못할 수 있어, 각각의 조건이 인덱스를 사용하도록 분리한 뒤 UNION으로 합쳤을 때 더 빠를 수 있기 때문에"
  }
]
} />


## Q&A
<iframe src="https://tally.so/embed/wbOOKg?alignLeft=1&hideTitle=1&transparentBackground=1&dynamicHeight=0" loading="lazy" width="100%" height="274" frameborder="0" marginheight="0" marginwidth="0" title="Q&A"></iframe>