# 색 보정

## 히스토그램
자 그 다음에 질문 또 있으신가 그 다음에 이제 색보정 우리가 색보정을 우리가 아까도 질문하신 질문 중에 그런게 있었는데 조도가 서로 안맞으면 어떻게 되느냐

우리가 사진 찍어보면 사진이 너무 밝게 나오거나 어둡게 나오거나 뿌옇게 나오거나 이런건 늘상 있는 일이란 말이에요

사실 요즘에 스마트폰 카메라가 워낙 좋아가지고 사실 그냥 대충 찍으면 알아서 자기가 다 보정을 해주긴 하는데 우리가 이제 일반적으로 공장에서 스마트폰 카메라처럼 좋은 카메라에 사실 이 스마트폰 생각해보면 되게 비싸잖아요

이게 사실 거의 대부분이 약간 한 이 가격에 제사하고 상당 부분은 좋은 사진을 찍는데 굉장히 많은 비용을 내고 있는건데 사실 이 정도로 좋은 비용을 들 필요가 있을까 결국 우리 얼굴 정도 찍을 우리 얼굴 찍자고 쓰기엔 너무 좋은 카메라입니다

어쨌든 이제 우리가 공장에서 이렇게 비싸고 좋은 카메라에 좋은 하드웨어에 이런걸 다 갖다 쓸 순 없단 말이에요

웹캠 이런걸로 찍으면 막 뿌얗고 보정이 하나도 안되있습니다

그러면은 이제 이런거를 이제 보정을 하려면 어떻게 해야 되냐

그 얘기를 좀 이번 시간에 해보도록 하겠습니다

그래서 우리가 이제 히스토그램이라는 걸 그릴 수 있는데 히스토그램은 원래 이제 통계에서 뭐냐면 뭐 예를 들면 여기 이제 사람들의 키가 있다

그럼

키를 이렇게 구간별로 잘라 가지고 뭐 150에서 160까지 160에서 170까지 170에서 180까지 이렇게 구간별로 잘라서 각 구간에 사람들이 몇 명 있는지 뭐 이런 식으로 이렇게 막대그래프로 나타내는 거를 히스토그램이라고 해요

원래는 이제 통계적으로 그런 의미인데 그럼 이제 결국에는 핵심 논리는 구간별로 잘라서 각 구간에 얼마나 있는지를 하는 거니까 이거를 그림에도 적용할 수 있겠죠

```python
import matplotlib.pyplot as plt
for i, color in enumerate('bgr'):
    hist = cv2.calcHist([image], [i], mask=None, histSize=[256], ranges=[0, 256])
    plt.plot(hist, color=color)
```
그래서 칼크 히스트라는 함수가 있는데 요 함수에다가 넣어주면은 뭘 해주냐

하면 색깔별로 이제 밝기가 얼마나 밝은지 어두운지를 히스토그램으로 계산을 해줍니다

그래서 여기 아래쪽에 보시면은 빨간색은 지금 보면은 약간 어두운 데가 좀 많고 아주 밝은 데는 잘 없는데 거의 매우 밝은 데는 오히려 조금 있어요

그죠

그림은 너무 밑에 있나요

그림 약간 확대를 해 드리면 여기 보시면은 빨간색은 대부분 0쪽에 많이 있습니다

그리고 중간이 이렇게 비어 있고 맨 끝에만 살짝 올라가 있거든요

왜 그러냐면은 그림을 보시면 빨간색 사실 거의 없고 아주 빨간 데가 여기 조금 있고요 그죠

그 다음에 흰 구름 같은 거 있는데 구름은 흰색이니까 빨강 파랑 초록이 다 최대로 있어야 흰색이 되거든요

요런 데랑 아주 빨간 데 요런 데만 조금 있고 빨간색 나머지 부분은 빨간색이 별로 없어요

그래서 빨간색 채널은 거의 0이고 파란색은 지금 보면은 굉장히 밝은 영역에 많이 있죠

왜 그렇겠습니까 하늘이 다 파란색이잖아요

이런 거 다 파란색이니까 파란색은 굉장히 좀 골고루 있는 편이죠

그래서 이걸로 이제 히스토그램을 우리가 그려보면은 색깔별로 어떻게 분포해 있는지 채널별로 밝기가 어떻게 분포했는지를 알 수가 있습니다

그래서 이렇게 분포를 알 수가 있고요 그래서 우리가 이제 요거를 밝기를 지금 예를 들면 빨간색 같은 경우에는 좀 어두운 데 많은데 그러면 밝은 쪽에 빨간색을 좀 높여준다든가 어두운 쪽에 빨간색을 좀 줄여준다든가 이러면은 빨간색을 전체 그림에서 균일하게 만들어 줄 수가 있겠죠

근데 사실 이제 이 그림 같은 경우는 굳이 그렇게 할 필요는 없는데 여기서 빨간색 균일하게 해서 뭐 하겠어요

근데 이제 가끔 밝기를 좀 균일하게 해 줘야 될 때가 있어요

## 히스토그램 균일화

```python
src = cv2.imread('xray.jpg', cv2.IMREAD_GRAYSCALE) # 흑백으로 열기
hist1 = cv2.calcHist([src], [0], mask=None, histSize=[256], ranges=[0, 256])
eqd = cv2.equalizeHist(src)  # 히스토그램 균일화
hist2 = cv2.calcHist([eqd], [0], mask=None, histSize=[256], ranges=[0, 256])
```

예를 들면은 우리가 이제 다음 장에 나오는 X-ray 사진 같은 경우인데 X-ray 여기 사진을 보시면 X-ray가 좀 전반적으로 뿌옇거든요

전반적으로 뿌옇다는 얘기는 뭡니까

이거를 히스토그램으로 그리면 이렇게 어중간한 밝은 데에서 히스토그램이 이렇게 올라가 있다니까 그러면은 이거를 그 오른쪽처럼 이렇게 전반적으로 좀 이렇게 균일하게 만들어주면은 완전히 균일하지는 않는데 요렇게 여기 지금 요런데가 제일 밝은 데가 지금 별로 없죠

그러니까 그 X-ray가 선명하게 보이려면 하얀 데는 하얗고 까만 데는 까맣고 이래야 되는데 전반적으로 다 뿌연니까 다 대충 회색톤이란 말이에요

회색톤이라는 건 여기 중간이 많다는 거죠

그래서 이 밝은 데 흰색 부분을 흰색 부분을 여기를 흰색 부분을 여기를 이렇게 이렇게 그려주시면 됩니다.

전반적으로 올려가지고 여기를 전반적으로 그다음에 여기 까만 데도 잘 없는데 까만 데도 좀 올려주고 그래서 이거를 전반적으로 톤을 맞춰주는 게 히스토그램 균일화입니다.

전반적으로 밝은 데는 밝게 어두운 데는 어둡게 이렇게 해가지고 톤을 맞춰주잖아요.

그래서 이렇게 히스토그램 균일화를 하면 이렇게 전반적으로 뿌였던 게 보시면은 하얀 데는 하얗게 나오고 검은 데는 검은 데는 검은 데는 검은 데는 검은 게 나와서 좀 더 선명하게 보이게 됩니다.

무조건 좋으냐 하면 무조건 좋은건 아니고 선명해지긴 하는데 여기 잘 보시면 갈비뼈 있는데 이런 데 보시면 갈비뼈는 원래 이렇게 뿌옇게 나왔는데 여기 너무 이렇게 하니까 오히려 갈비뼈는 잘 안보이거든요

보시면 이제 척추 이런 데는 잘 보이죠

오히려 잘 보이는 데도 있고 약간 균일화 해가지고 오히려 좀 안 보이게 된 데도 있고 그렇습니다

그래서 이제 히스토그램 균일화는 여기 보시면 equalize-hist 라는 걸 써가지고 히스토그램을 균일하게 만들 수가 있습니다

위의 랑 밑에는 그냥 히스토그램을 그려주는 거고 사실 이거 균일하는 건 이거 한 줄이에요

그래서 직접 해보면 첫 번째 줄은 src 이거는 이제 image.fromarray 이렇게 보시면 됩니다

그래서 이거는 열때부터 그레이스케일 흑백으로 열었기 때문에 그냥 show가 아니라 fromarray로 보셔야 돼요 전반적으로 보면은 이렇게 뭐가 다 뿌옇게 돼가지고 이런 데가 이제 잘 안보이죠

이런 데가 좀 선명하게 잘 안 보이는데 그래서 이제 밝은 데는 밝게 어두운 데는 어둡게 이렇게 만들어 줄 겁니다

그래서 이제 히스토그램을 그려보면 히스토그램을 그려보면 어두운 데랑 밝은 데가 잘 없고 이제 회색 영역이 많이 있어요

있긴 있는데 그 코드를 또 짜서 해가지고 일단은 요건 잠깐 접어 두겠습니다

그래서 요렇게 해가지고 흑백으로 여서 이제 보고 요건 이제 히스토그램이고 그래서 이제 히스토그램 균일화를 한 다음에 image.fromarray 해가지고 eqd 이렇게 해서 보면은 훨씬 요런데가 다 이제 척추에 핀 같은 걸 꽂았나봐요

그죠?

여기 보시면은 핀 같은 거 이렇게 꽂혀 있는데 원래는 좀 흐리멍텅해서 잘 안 보이던 게 요런데가 이제 좀 더 잘 보이죠

다 접어버립시다

그래서 요거가 이제 슬라이드 57쪽인데 화면에 보여주는 것만 제가 이렇게 추가를 했어요

그래서 plt.flot하면 이제 plot을 화면에 그려주는 거고 image.fromarray 이거는 이제 흑백을 보여주는 겁니다

우리가 이제 show 함수는 color에만 쓰시는 거예요

이거는 이제 그래프 그려주는 툴이에요

그 다음에 지금 이 이퀄라이즈 히스트를 써서 히스토그램 균일화를 하면 한 가지 문제가 있는데 이미지의 밝기를 전반적으로 그냥 조정을 해버리거든요

근데 이미지라는 게 어떤 데는 좀 어두운 부분이 있고 어떤 데는 좀 밝은 부분이 있는데 그 밝기를 전반적으로 조절을 해버리니까 약간 좀 이상하게 되는 데가 있어요

## CLAHE

```python
clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
clahed = clahe.apply(src)
```

그래서 그런 문제들을 보완한 알고리즘들이 있는데 그 중에 하나가 클라헤?

이것도 이제 보시면 뒤에 HE는 그냥 여기 HE라고 되어 있는 거는 이게 히스토그램 균일화입니다

히스토그램 균일화인데 두 가지를 추가를 한 거예요

뭘 추가를 했냐면 일단 그림에 밝은 데랑 어두운 데가 있으니까 그림을 고정된 크기로의 타일로 나눕니다

그래서 원본 그림이 이렇게 있으면 이거를 그림을 이렇게 블럭으로 나눠요

그러면 대체로 여기서는 밝기가 비슷하겠죠?

그리고 여기서도 밝기가 비슷하겠죠?

그래서 타일로 나눠 가지고 그 타일 안에서 조정을 해 주는 거예요

전체적으로 조정해 주는 게 아니라 그 타일 내에서 이제 조정을 하는 게 첫 번째고 그다음에 이제 또 하나는 뭐냐 하면 타일 내에서 히스토그램을 그렸는데 여기에 밝기가 이렇게 툭 튀어나와 있는데 이게 그냥 노이즈 때문에 튀어나와 있는 거일 수도 있어요

그래서 이렇게 튀어나와 있는 게 있으면 일정 기준을 정해서 일정 기준보다 튀어나온 게 있으면 그거를 다 깎아내 가지고 전반적으로 밝기를 높여 줍니다

그래서 원래 모양이 히스토그램이 이렇게 돼 있었으면 히스토그램이 이렇게 바뀌어요 튀어나온 데는 깎아 가지고 전반적으로 뿌려주는 그런 식으로 조정을 해 줍니다

그래서 여기 보시면 클립 리미트랑 타일 그리드 사이즈가 있는데 여기 8,8은 가로 세로 8픽셀씩 이렇게 쪼개 준다는 얘기고 그 다음에 클립 리미트 2.0은 이 한도를 어떤 거에 2배 이런 식으로 잡아놓는 거 그래서 이거를 한도를 높일 수도 있고 낮출 수도 있습니다

이런 거는 숫자가 딱 정해져 있는 건 아니고 이 숫자를 바꿔가면서 적당한 숫자를 찾으셔야 돼요

그래서 이걸로 해 보면 이렇게 나오는데 아까 앞에 거랑 좀 비교를 해 보시면은 뭐 크게 차이가 나진 않지만 그래도 조금 더 선명해 보이거든요

이런 데 보면은 여기 갈비뼈가 좀 잘 안 보이는데 이런 데서 왜냐면 밝기를 전반적으로 조절하니까 어두운 부분은 또 너무 어두워지는 그런 문제가 있어요

근데 여기서는 보시면은 갈비뼈가 잘 보이거든요

어두운 애들은 어두운 애들끼리 밝기를 조절해 주고 밝은 애들은 밝은 애들끼리 밝기를 조절해 주니까 조금 더 선명하게 보이는 거죠

비교를 좀 해 보시면은 이런 데 여기 그 여기 장기 있는데 이런 데에도 여기는 다 너무 하얀데 여기 보시면 뭐 이런 데 지금 보면 뼈나 이런 게 좀 더 잘 보입니다

블럭으로 나눠서 보여주기 때문에 히스토그램을 조정을 하기 때문에 전반적으로 좀 더 잘 보인다

그리고 이제 이거의 전체 히스토그램을 보시면 아까 거는 보면은 히스토그램을 전반적으로 다 올리니까 이런 데 밝은 데가 다 올라가거든요

여기서는 밝은 데가 별로 올라가지가 않았어요

왜 그러냐면 그 블럭으로 나눠서 전체적으로 다 밝기를 조절하는 게 아니라 그 블럭 내에서 밝기를 조절을 하니까 전체적인 히스토그램의 윤곽을 보시면 여기 이제 어두운 게 있고 밝은 데 있는데 여전히도 이런 데는 별로 안 올라갔죠

그래서 이미지 전체가 아니라 이미지를 타일로 나눠서 부분 부분 부분 별로 히스토그램을 조정을 해 주는 이런 방식이 클라에라는 알고리즘입니다.

클라에라는 알고리즘입니다.

그래서 이것도 한 다음에 image.fromArray 해가지고 클라에드 이렇게 해 보시면은 선명하게 보실 수가 있고 그래서 이제 클립리미트나 이 타일그리드 사이즈를 바꿔 보시면 클립리미트를 4로 올려볼까요?

클립리미트를 4로 올려볼까요?

그러면은 이미지가 달라지는 게 보이시죠?

16 이렇게 하면 요런데에도 지금 보시면 32 약간 형체가 안 보이기 시작하는데 너무 과장돼서 이렇게 나와요

2랑 비교해 보시면 32랑 2랑 비교해 보시면 32라고 보시면 3로 올렸어요.

32는 요렇게 나오고 2 하면은 이렇게 이런 식으로 할 수도 있고 타일 리미트도 이제 바꿔 보죠

그래서 이제 우리가 어떤 보고자 하는 그런 부분들이 가장 잘 보이게 이제 이런 수치를 조절을 해 주시면 됩니다

예를 들면 우리가 병원 같은 데다가 이제 이런 걸 한다고 하면은 이제 그 수치 어차피 X-ray 맨날 비슷비슷하게 찍힐 거니까 이 X-ray 장비의 특성 때문에 이렇게 나오는 거잖아요

그러니까 이 숫자를 제일 잘 보이게 딱 한 번 잡아주면은 계속 그 숫자로 적용을 해 주면 되겠죠

## 컬러 이미지의 히스토그램 균일화

```python
src = cv2.imread('low.jpg')
b,g,r = cv2.split(src)
eqd1 = cv2.merge(
  (cv2.equalizeHist(b), cv2.equalizeHist(g), cv2.equalizeHist(r)))
```

자 그래서 지금 우리 이제 엑스레이 같은거는 흑백이니까 뭐 간단한데 컬러는 또 좀 다른 문제가 생깁니다.

컬러 이미지는 RGB가 있는데 우리가 이제 밝기를 채널별로 조절하거든요.

채널별로 조절하면 문제가 뭐냐면 레드는 밝기가 전반적으로 올라가고 그리는 밝기가 전반적으로 내려가고 이러면은 색깔이 바뀌어버려요.

레드 그린 블루의 그 저기 뭐죠

비율에 따라서 색깔이 결정이 되는데 비율이 깨져버리니까 지금 보시면은 59쪽인데 제일 상단에 있는게 원본입니다.

근데 지금 이미지가 전반적으로 이것도 뿌연데

그러니까 이제 그 뭐죠

이런거 뭐가 안 맞아 하여간 사진이 좀 잘못 찍혔어요.

노출을 좀 잘못해가지고 선명하지가 않고 지금 뿌옇게 찍혔는데 이거를 히스토그램 균일화를 하니까 파란색이 너무 올라와가지고 이렇게 이런 데가 다 파랗게 돼버렸습니다.

선명해지긴 했는데 이런 데 보시면 굉장히 선명해졌죠.

선명해지긴 했는데 이 색깔 균형이 안 맞아가지고 그 색깔이 지금 왜곡이 됐어요.

왜 그러냐면 이제 BGR에서 균일화를 했기 때문입니다.

```python
hsv = cv2.cvtColor(src, cv2.COLOR_BGR2HSV)
h,s,v = cv2.split(hsv)
eqd_v = cv2.equalizeHist(v)
mgd = cv2.merge((h,s,eqd_v))
eqd2 = cv2.cvtColor(mgd, cv2.COLOR_HSV2BGR)
```

그래서 컬러 이미지 같은 거에 따라서는 지금 보면은 명도가 문제잖아요.

전반적으로 너무 밝단 말이에요.

사진이 그러니까 그 밝기 때문에 밝기를 조절을 해주셔야 됩니다.

밝기가 밝은 데는 밝게 어두운 데는 어둡게 그래서 HSV로 일단 한번 바꿔요.

HSV로 바꿔가지고 요거를 스플릿하시면 HSV가 따로따로 나오겠죠.

그래서 요 V만 이퀄라이징을 해주시는 겁니다.

지금은 그냥 이퀄라이징 시스템인데 클라헬을 적용하셔도 되고요.

그거는 이제 한번 해보세요.

그래서 V만 이퀄라이징 시킨 다음에 다시 Merge를 하는데 HSV가 아니라 이퀄라이징 된 V를 넣어 주는 거죠.

그래서 다시 HSV를 이제 이 MZD는 HSV니까 BGR로 바꿔주면은 EQD2 하면은 이제 이퀄라이징 된 상태가 됩니다.

그래서 요거가 지금 슬라이드 59쪽이고요.

여기 EQD라고 돼 있는데 강의 자료 오류입니다.

MZD라고 하셔야 돼요.

그래서 Show EQD1 하면은 Show EQD1 하면은 Show EQD1 하면은 Show EQD1 하면은 색깔이 이상하죠.

파랗게 됐죠.

Show EQD2 하면은 굉장히 선명하게 사진이 됩니다.

원본을 보시면은 SRC라고 하시면 되는데 원본은 지금 사진이 너무 밝아 전반적으로 밝아 가지고 뿌예요.

여기 강의자료에 여기 마지막 줄이 잘못되어 있는데 여기 EQD를 바꾸라고 되어 있는데 MGD를 바꾸셔야 됩니다.


## 히스토그램을 이용한 이진화


지금 약간 화질이 떨어지는건 어쩔 수 없는거지만 그래서 이런식으로 하얀 데는 하얗게 까만 데는 까맣게 만드는거를 이진화라고 합니다.

둘 중에 하나로 만든다는거에요.

그래서 이렇게 이진화를 하는데 그러면은 뭘 기준으로 하얗다 까맣다를 가릴거냐 하는 문제가 생깁니다.

그래서 한가지 방법은 히스토그램을 그려보는거에요.

```python
src = cv2.imread('newspaper.png', cv2.IMREAD_GRAYSCALE)
hist = cv2.calcHist([src], [0], mask=None, histSize=[256], ranges=[0, 256])
```
히스토그램을 그려보면은 대충 여기까지는 고만고만 하다가 여기서부터 색깔이 확 나오기 시작하거든요.

그러니까 지금 보시면 여기 신문을 보면은 여기 신문지 색깔이 있잖아요.

희뿌연 색깔.

그래서 그 부분이 어디냐면은 여기겠죠.

여기서 이제 푹 튀어나와 있으니까.

그러면은 우리가 이 신문지 색깔인 부분하고 글자 색깔인 부분하고 경계를 찾아야 되는데 그래서 대충 한 요정도가 아마도 경계선일겁니다.

왜냐면 글자는 어두운 쪽이니까 요쪽일거고 신문지 배경은 밝은 쪽이니까 요쪽일거고 그래서 히스토그램을 보고 눈으로 찾아가지고 여기 위에는 이제 히스토그램을 그리는 부분이구요.

```python
th, bin = cv2.threshold(src, 190, 255, cv2.THRESH_BINARY)
```

눈으로 찾아가지고 0에서 190까지는 까만색 190에서 255까지는 흰색으로 이진화를 할 수 있습니다.

그래서 여기 Threshold라는 함수가 있는데 Threshold는 이제 문턱이라는 뜻이죠.

문턱값.

그래서 문턱을 190으로 정해서 190을 넘어가는 애들은 255로 만들고요.

이게 이제 문턱이고.

문턱을 넘어가는 애들은 255로 만들고요.

문턱을 넘어가면 모두 255입니다.

191도 255, 192도 255, 193도 255 그럼 문턱을 못 넘어가면 어떻게 되느냐

여긴 따로 말이 없는데 0으로 만들어줍니다.

그래서 이 Threshold함수를 쓰면 0 아니면 255 까만 아니면 흰색으로 바뀌어요.

그래서 문턱값을 이렇게 딱 정해주시면 됩니다.

근데 이제 지금은 눈으로 보고 했는데 약간 번거롭잖아요.

그래서 뒤에서 나중에 해볼건데 OATS의 이진화 알고리즘이라고 해서 그냥 여기다가 Threshold OATS 이렇게 해주면 자기가 자동으로 적당한 밝기를 찾아줘요.

그래서 사실은 이 Threshold를 지정을 굳이 손으로 하실 필요는 없습니다만 지금 한번 해보는 거죠.

그래서 여기다가 190 이렇게 해가지고 한번 해보겠습니다.

그래서 일단 히스토그램을 그려보면 PLT.플롯히스트 이렇게 해보면 이렇게 나오는데 밝기가 지금 190에서 여기서부터 쭉 올라가는 게 보이시죠?

그러니까 신문지 배경이 여기라는 거를 우리가 알 수 있어요.

왜냐하면 배경이 제일 많잖아요.

여기 어디 갔습니까?

여기가 배경색인 부분이 많기 때문에 여기가 튀어 올라갔다는 거는 여기가 튀어 올라간 게 배경색이겠구나.

배경색을 쳐내야 되니까 배경색을 쳐내야 되니까 190에서 190을 경계로 잘라주면 이렇게 되겠죠.

그래서 보면 이 신문지를 잘 보시면 여기 보면 뒤에 있는 글자 같은 게 비쳐 보이거든요.

잘 보시면 노동이 이렇게 비쳐 보이는데 이렇게 Threshold로 잘라버리면 이런 비쳐 보이는 부분이 다 날라가죠.

그래서 더 선명하게 만들 수가 있습니다.

그런데 여기 Threshold를 지금 잘라주면 이렇게 빛이 보이고 이렇게 빛이 보이고 이렇게 빛이 보이고 Threshold를 지금 제가 190으로 해놨는데 이걸 낮춰버리면 어떻게 되느냐?

100 이렇게 낮춰버리면 어떻게 되냐?

너무 많이 날려버려.

너무 낮은 데서 하니까 하나도 없고 그렇다고 이거를 너무 올리면 200 이렇게 하면 이런 배경으로 있던 까만 게 복사 많이 하면 이렇게 되죠.

배경으로 있던 까만 게 비춰 보이거든요.

## 오츠의 이진화 알고리즘

```python
th, bin = cv2.threshold(src, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)
```

Oats의 이즈나 알고리즘이라는게 있는데 여기 뒤에다가 긴 짝대기는 이거 어딨냐면 키보드에 보시면 키보드 제일 오른쪽에 백스페이스랑 엔터 사이에 보시면 이렇게 짝대기 모양의 버튼이 있습니다

이렇게 키보드에 보시면 짝대기 있고 원화 있고 요건데 요 짝대기에요

그래서 요걸 하면은 요 두개를 합쳐서 이 옵션을 두개를 합쳐줍니다

그래서 여기 오츠의 알고리즘을 이용해서 문턱값을 설정을 해라 여기 숫자 0으로 해놨는데 요거를 설정해라

이렇게 하면은 원본은 요런건데 요거를 이제 문턱값을 계속 이렇게 올려주면은 요런식으로 변해가는데 요중에서 제일 균일한게 뭐냐

이런거에요

그러면은 이건 다 너무 까맣고 이건 다 너무 하얗잖아요

제일 균일한건 한 요정도겠죠

요정도가 제일 밝은색이랑 까만색이 제일 균일하게 요정도가 제일 밝은색이랑 까만색이 제일 균일하게 있는거죠

그래서 고문턱값을 찾아줍니다

그래서 우리꺼에도 이제 적용을 해보면 여기다가 해주시면은 요렇게 나오고 요 ThreadSold값이 얼반지에 보려면 여기 Th가 ThreadSold값이거든요

그래서 Th를 보면은 169.0일때가 가장 색깔이 흰색까만색이 가장 균일하게 잘 잡힌다 우리는 190으로 잡았었는데 고거는 좀 많이 잡아줬던거였죠

눈으로 보고 대충 잡으면 그렇게 됩니다

그래서 이렇게 해보시면 이제 요 문턱값을 169.0으로 할 때가 흰색까만색이 균일이 있게 나온다

문턱값을 169.0으로 할 때가 제일 흰색까만색이 균일한게 나온다

## global thresholding의 문제

```python
th, bin = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)
```

우리가 지금 하고 있는게 글로벌 스레스 솔딩인데 글로벌 스레스 솔딩이 뭐냐면 문턱값이 지금 딱 하나에요 169 이래가지고 모든거를 밝기 169 기준으로 하는데 아까 신문같은거는 지금 스캔한거라서 밝기가 전반적으로 균질하거든요

근데 이제 사진을 이렇게 지금 보시면 이게 그 신문을 카메라로 핸드폰 카메라로 찍으면 밝기가 균질하지 않고 지금 눈으로 보면 거의 비슷해 보이지만 여기는 좀 어둡고 여기는 좀 밝고 이렇게 나옵니다

핸드폰 카메라로 아무리 잘 찍어도 밝기가 균질하게 나올 수가 없어요

그래서 이거를 스레스 솔딩을 적용을 하면은 이런 데가 다 꺼먹게 되버립니다

그런 문제가 있죠

그래서 이렇게 밝기가 균질하지 않은 경우에는 문턱값을 하나를 정해버리면 안 돼요

## Adaptive Thresholding

그럼 어떻게 하면 될까요

사실 우리가 앞에서 이미 봤는데 클라에 같이 구간 구간 구간으로 나눠서 밝은 부분은 밝은 부분끼리 자기들끼리 비교해서 하고 어두운 부분은 어두운 부분들끼리 비교를 해서 자기들끼리 하고 이렇게 하면 되겠죠

```python
# 이미지를 여러 개의 블록으로 나누어 이진화
block_size = 15  # 주변 15픽셀을 참고
C = 5  # 가감할 상수
# 주변 픽셀의 평균을 이용: 선명하지만 노이즈
adap2 = cv2.adaptiveThreshold(
    gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, 
    cv2.THRESH_BINARY, block_size, C)
# 가우시안 분포를 이용: 노이즈가 적음
adap3 = cv2.adaptiveThreshold(
    gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
    cv2.THRESH_BINARY, block_size, C)
```

그래서 이런 걸 어댑티브 스레스 솔딩이라고 하는데 여기 보시면 cv2.

어댑티브 스레스 솔드 이렇게 해가지고 요 블록 사이즈가 있습니다 블록 사이즈를 15로 해줍니다.

이렇게 하면은 자기 주변에서만 밝기를 비교를 하는 거예요

그래서 자기 주변보다 상대적으로 밝으면 밝은 걸로 하고 자기 주변보다 상대적으로 어두우면 어두운 걸로 하고 그래서 보시면은 여기 보면은 여기 어두운 부분에서는 어두운 부분끼리 비교하니까 이렇게 선명하게 나오고 밝은 부분은 또 밝은 부분끼리 선명해서 선명하게 나오고 여기 앞에 여기 왼쪽 폰카로 찍은 걸 그냥 스레스 솔드를 적용하면은 이렇게 나오는데 어댑티브 스레스 솔드를 하면은 이렇게 선명하게 이렇게 나오게 됩니다

근데 이제 이것도 이제 방법이 두 가지가 있는데 여기 보시면은 어댑티브 스레스 솔드 민 c가 있고 어댑티브 스레스 솔드 가오시안 c가 있는데 이거는 뭐냐면 민 c는 이제 민이 평균이라는 뜻이거든요

자기 주변에 15개의 픽셀을 참고를 하는데 그거에 평균값을 이렇게 내 가지고 그걸 이용을 해서 하면은 이제 이거고 가오시안 분포라는 건 이제 여러분 아시는 정규분포를 이용을 하는 겁니다

그리고 그 커트를 정하는 건데 일장에 일단 있어요

이 민 c를 쓰시면 좀 선명하지만 여기 보시면 이렇게 노이즈가 좀 생깁니다

자글자글하게 왜냐하면 평균보다 높으면은 높으면 흰색 낮으면 까만색 이러니까는 평균보다 살짝만 내려가도 이렇게 까뭇까뭇하게 노이즈가 많이 생기거든요

근데 이제 그 가오시안 분포를 이용해서 하면은 뭐 비슷하지만은 거의 좀 별 차이가 없고요 차이가 없긴 한데

이런데 이제 그 점 있는 거 보면은 조금 덜 더 작아요

약간 노이즈가 조금 더 적게 나옵니다

그 대신에 보시면 여기 1 같은 거 보면은 여기서는 되게 뚜렷하게 1이 되는데 여기 약간 1이 좀 쥐 파먹은 것처럼 이렇게 나오죠

그러니까 좀 가오시안으로 하면은 노이즈는 살짝 적은데 선명도가 좀 떨어진다

근데 사실 뭐 그렇게 큰 차이가 나는 건 아니라서 이거는 이제 돌려보시고 어느 게 더 내 상황에서 잘 맞는다

그러니까 예를 들면 우리가 노이즈가 더 잘 생기고 우리가 노이즈가 별로 없는 상황이면은 굳이 가오시안을 할 필요가 없죠

노이즈 없는데 뭐하러 노이즈가 적은 방법을 쓰겠어요

근데 만약에 좀 노이즈가 많은 환경이다

그러면은 가오시안을 쓰시는 게 맞겠죠

그래서 이거는 이제 둘 다 옵션에 있는 민 C하고 가오

시안 C하고 이것만 달라지는 거니까 이거는 이제 바꿔 보시면 되고 그다음에 여기 Thresh Binary라든가 이런 거는 앞에랑 똑같습니다

그래서 블록 사이즈랑 C가 있는데 이거는 이제 이것도 이 부분을 좀 더 조절을 해 보시면 돼요

적당하게 그래서 이렇게 하면은 우리가 이미지를 선명하게 바꿀 수 있다

그래서 그 요즘에 스마트폰 앱 중에 그냥 사진만 찍어도 스캔한 것처럼 만들어 주는 앱들이 있거든요

보시면은 이 알고리즘이 들어가 있습니다

대충 찍어도 밝기를 균일하게 만들어줘요