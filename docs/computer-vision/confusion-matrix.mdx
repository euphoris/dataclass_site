# 혼동 행렬

## Fashion MNIST
*   MNIST 데이터셋이 너무 쉬워서 똑같은 형식으로 더 어렵게 만든 데이터셋
    *   T-shirt/top : 0
    *   Trouser : 1
    *   Pullover : 2
    *   Dress : 3
    *   Coat : 4
    *   Sandal : 5
    *   Shirt : 6
    *   Sneaker : 7
    *   Bag : 8
    *   Ankle boot : 9

## Fashion MNIST
```python
import os
os.environ["KERAS_BACKEND"] = "torch"
import keras
(x_train, y_train), (x_test, y_test) = keras.datasets.fashion_mnist.load_data()

# 스웨터(2)와 셔츠(6)
x_train_binary, y_train_binary = filter_binary(x_train, y_train, 2, 6)
x_test_binary, y_test_binary = filter_binary(x_test, y_test, 2, 6)

```

## Fashion MNIST 모델 학습
```python
model = keras.models.Sequential(
    [
        keras.layers.Rescaling(1/255),
        keras.layers.Flatten(),
        keras.layers.Dense(1, activation='sigmoid')
    ]
)
model.compile(optimizer=keras.optimizers.SGD(learning_rate=0.001), 
              loss='binary_crossentropy', metrics=['accuracy'])
model.fit(x_train_binary, y_train_binary, epochs=5, batch_size=32)
```

## 정답과 확률 수집

```python
import numpy as np
y_prob = model.predict(x_test_binary) # 예측 확률
threshold = 0.5 # 문턱값
y_pred = np.where(y_prob >= threshold, 1, 0) # 문턱값보다 크면 1 아니면 0
```


## 혼동 행렬 confusion matrix
|     |     |**예측**||
|:---:|:---:|:---:|:---:|
|     |     |**음성 (0)**|**양성 (1)**|
|**실제**|**음성 (0)**|TN|FP|
|        |**양성 (1)**|FN|TP|

```python
from sklearn.metrics import * # sklearn.metrics 모듈에서 모든 함수 불러오기
y_true = y_test_binary # 실제 정답
confusion_matrix(y_true, y_pred) # 혼동행렬(정답, 예측 순)
```

## 진/위 양성/음성
*   혼동행렬에서 양성/음성은 예측을 기준으로 말함
*   현실에서는 실제로 어떤지 알 수 없는 경우가 많음
*   진(True) → 예측이 맞음
*   위(False) → 예측이 틀림


## 정확도 accuracy
*   전체 중에 예측이 맞은 비율
    `(TP + TN) / 전체`
*   특별히 음성/양성 구분에 관심이 없는 경우 사용
*   그러나 대부분은 양성에 더 관심이 있음
```python
accuracy_score(y_true, y_pred)
```

## 정밀도 precision
(예측 양성 열에서 실제 양성 칸이 강조된 혼동행렬 다이어그램)

## 정밀도 precision
*   양성 예측 중에 맞은 비율
    `TP / (TP + FP)`
*   양성 예측이 중요한 경우 (예: 채용, 투자, 추천, 결혼 등)
```python
precision_score(y_true, y_pred)
```

## 재현도 recall
(실제 양성 행에서 예측 양성 칸이 강조된 혼동행렬 다이어그램)

## 재현도 recall
*   실제 양성 중 찾아낸 비율
    `TP / (TP + FN)`
*   양성을 찾아 내는 것이 중요한 경우 (예: 방역)
*   의학 등에서는 민감도(specificity)라고도 함
*   또는 TPR(True Positive Rate)
```python
recall_score(y_true, y_pred)
```

## 특이도 specificity
*   실제 음성 중 찾아낸 비율
    `TN / (TN + FP)`
*   음성을 찾아 내는 것이 중요한 경우 (예: 방역)
*   대체로 양성 예측을 보수적으로 하면 특이도가 높아진다
*   FPR(False Positive Rate):
    `FP / (TN + FP) = 1 - specificity`
```python
recall_score(y_true, y_pred, pos_label=0)
```

## 특이도가 낮을 경우 문제점
*   질병 검사에서는 음성이 양성보다 훨씬 많음
*   특이도가 낮으면 정밀도가 떨어짐
*   예) 실제 양성이 1%인 경우

| | 예측 | |
| :--- | :---: | :---: |
| | **음성** | **양성** |
| **실제** **음성** | 9900 | 0 |
| **실제** **양성** | 2 | 98 |
> 특이도 100%
> 민감도 98%
> 정밀도 100%

| | 예측 | |
| :--- | :---: | :---: |
| | **음성** | **양성** |
| **실제** **음성** | 9504 | 396 |
| **실제** **양성** | 10 | 90 |
> 특이도 96%
> 민감도 90%
> 정밀도 18.5%

## F1
*   정밀도(p)와 재현도(r)의 조화 평균
    ` (2pr) / (p + r) `
*   조화평균: 역수의 평균의 역수
*   비율, 속도 등을 평균낼 때는 산술평균 대신 조화평균을 사용
```python
f1_score(y_true, y_pred)
```

## 퀴즈

| | 예측 | |
| :--- | :---: | :---: |
| | **음성** | **양성** |
| **실제** **음성** | 521 | 115 |
| **실제** **양성** | 373 | 629 |

import { QuizComponent } from "@/components/QuizComponent";

<QuizComponent quizId="confusion-matrix" quizItems={
[
    {
        "item_type": "radio",
        "question": "아래에서 정확도(accuracy) 공식을 골라보세요",
        "options": [
            "(TP + TN) / (TP + TN + FP + FN)",
            "TP / (TP + FP)",
            "TP / (TP + FN)",
            "TN / (TN + FP)"
        ],
        "hint": "전체 예측 중에서 올바르게 예측한 비율을 의미합니다.",
        "solution": "(TP + TN) / (TP + TN + FP + FN)"
    },
    {
        "item_type": "number",
        "tolerance": 0.01,
        "question": "위 혼동행렬의 정확도(accuracy)를 소수점 둘째 자리까지 계산하세요.",
        "hint": "정확도(accuracy) 공식은 다음과 같습니다: (TP + TN) / (TP + TN + FP + FN)",
        "solution": 0.702075702075702
    },
    {
        "item_type": "radio",
        "question": "아래에서 정밀도(precision) 공식을 골라보세요",
        "options": [
            "(TP + TN) / (TP + TN + FP + FN)",
            "TP / (TP + FP)",
            "TP / (TP + FN)",
            "TN / (TN + FP)"
        ],
        "hint": "모델이 Positive라고 예측한 것들 중에서 실제로 Positive인 것의 비율입니다.",
        "solution": "TP / (TP + FP)"
    },
    {
        "item_type": "number",
        "tolerance": 0.01,
        "question": "위 혼동행렬의 정밀도(precision)를 소수점 둘째 자리까지 계산하세요.",
        "hint": "정밀도(precision) 공식은 다음과 같습니다: TP / (TP + FP)",
        "solution": 0.8454301075268817
    },
    {
        "item_type": "radio",
        "question": "아래에서 재현도(recall) 공식을 골라보세요",
        "options": [
            "(TP + TN) / (TP + TN + FP + FN)",
            "TP / (TP + FP)",
            "TP / (TP + FN)",
            "TN / (TN + FP)"
        ],
        "hint": "실제 Positive인 것들 중에서 모델이 Positive라고 예측한 것의 비율입니다. 민감도(Sensitivity)라고도 합니다.",
        "solution": "TP / (TP + FN)"
    },
    {
        "item_type": "number",
        "tolerance": 0.01,
        "question": "위 혼동행렬의 재현도(recall)를 소수점 둘째 자리까지 계산하세요.",
        "hint": "재현도(recall) 공식은 다음과 같습니다: TP / (TP + FN)",
        "solution": 0.627744510978044
    },
    {
        "item_type": "radio",
        "question": "아래에서 특이도(specificity) 공식을 골라보세요",
        "options": [
            "(TP + TN) / (TP + TN + FP + FN)",
            "TP / (TP + FP)",
            "TP / (TP + FN)",
            "TN / (TN + FP)"
        ],
        "hint": "실제 Negative인 것들 중에서 모델이 Negative라고 예측한 것의 비율입니다.",
        "solution": "TN / (TN + FP)"
    },
    {
        "item_type": "number",
        "tolerance": 0.01,
        "question": "위 혼동행렬의 특이도(specificity)를 소수점 둘째 자리까지 계산하세요.",
        "hint": "특이도(specificity) 공식은 다음과 같습니다: TN / (TN + FP)",
        "solution": 0.8191823899371069
    }
]
} />


## Q&A
<iframe src="https://tally.so/embed/wbOOKg?alignLeft=1&hideTitle=1&transparentBackground=1&dynamicHeight=0" loading="lazy" width="100%" height="274" frameborder="0" marginheight="0" marginwidth="0" title="Q&A"></iframe>