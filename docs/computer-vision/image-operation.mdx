# 이미지 연산

## 이미지 덧셈



제일 간단한 것은 이미지끼리 더하는 것입니다.

이미지끼리 더한다는 것은 무슨 말이냐면 어차피 이미지라는게 그 픽셀의 밝기기 때문에 밝기와 밝기를 더해주면 됩니다

예를 들면 우리가 지금 여기 이미지가 있는데 Show Image 하면은 이미지가 이런 풍선 이미지가 있죠

```python
cv2.add(image, 100)
```

어 근데 강의 자료 이제 46쪽에 있는 것처럼 cv2.add 한 다음에 이미지, 100 이렇게 해주고 아 하면은 안되고 예 이거를 Show 이렇게 해주셔야 됩니다

그러면은 어 이미지가 어딘가 모르게 전반적으로 좀 밝아졌죠

왜냐하면 모든 픽셀의 밝기를 100만큼 증가시켰기 때문에 그렇습니다

만약에 여기를 200으로 바꾸면 어떻게 될까

200으로 바꾸면 더 밝아졌죠

300으로 바꾸면 이제 흰색 밖에 안나옵니다

이렇게 하면은 이렇게 하면은 이미지가 255로 너무 많은 이미지로 다 더해지게 되는 거죠

그래서 cv2.add 한 다음에 어떤 이미지가 있고 숫자가 있으면 일괄적으로 다 더해주는데 이미지의 밝기는 255를 넘을 수가 없기 때문에 어떻게 하냐면은 255를 넘으면 거기서 끊어줘요

그러니까 256부터는 그냥 다 255로 표현을 해줍니다


두 개의 이미지 더하기
```python
chair = cv2.imread('chair.webp')
explosion = cv2.imread('explosion.webp')
cv2.add(chair, explosion)
```

가중치를 곱하여 더하기(2:8로 더하고 일괄적으로 10 더함)
```python
cv2.addWeighted(chair, 0.2, explosion, 0.8, 0)
```


## 이미지 뺄셈

```python
cv2.subtract(image, 100)
```

subtract는 별건 아니고 일괄적으로 빼주는데 이미지의 밝기가 0보다 밑으로 내려갈 수가 없기 때문에 0보다 작으면은 0으로 만들어요.

이것도 subtract 대신에 그냥 빼도 되거든요.

그냥 이미지 빼기 이렇게 해도 되는데 그럼 아까처럼 overflow가 나가지고 색깔이 또 이상하게 깨집니다.

그래서 그런거를 막으려면은 꼭 이미지에 뭔가 더하거나 빼줄 때는 함수로 add나 subtract로 해주셔야지 색깔이 이상하게 뒤집히는거를 막을 수가 있어요.

```python
black_circle = cv2.imread('black_circle.png')
cv2.subtract(chair, black_circle)
```

그 다음 이제 이미지 두 장을 빼는 경우가 있는데 이미지 두 장을 빼면은 두 개의 어떤 차이를 구할 수 있겠죠.

근데 이 이미지 두 장 빼는거가 욕이 날 때가 있는데 언제 욕이 나냐면 아까 말씀하신 것 중에 이제 그 작업자가 나와서 일을 하는지 안 하는지 보고 싶다.

요거를 가장 간단하게 구현하는 방법은 그냥 이미지 두 장을 빼버리는 겁니다.

이미지 두 장을 빼면 어떻게 되느냐

그 이미지를 처음에 이제 예를 들어서 그 웹캠이 어디 이렇게 작업장을 비추고 있어요.

근데 작업장에 아무 변화가 없을 거 아니에요.

그러면 작업자가 안 나오면 그러면은 앞에 이미지랑 뒤에 이미지를 빼면은 1 빼기 1은 0이니까 그냥 까만색만 나오겠죠.

그러다가 작업자가 나타나면 작업자는 앞에 장면에 없던 사람이니까 작업자가 있는 화면에서 작업자가 없는 화면을 빼면은 그 작업자 있는 부분만 뭔가 이렇게 나오고 그 배경은 그냥 다 날라가 버린단 말이야.

물론 뭐 배경에 낙엽이 날아간다든지 이러면 그런 것도 잡히겠지만 뭐 그런 건 빼고 그러면은 작업자가 있으면은 작업자가 나오고 작업자가 없으면 배경 빼기 배경 해서 0이 되니까 까맣게 나오고 그래서 화면에 뭐가 밝게 있으면 아 이건 작업자가 있구나.

이런 식으로 하면은 가장 간단하게 아무 머신러닝이나 아무 복잡한 알고리즘을 안 쓰고도 작업자가 있는지 없는지 판정을 할 수가 있습니다.

이해 되시죠?

그래서 그런 식으로 구현을 할 수가 있고요.

```python
cv2.absdiff(chair, explosion)
```

그다음에 이제 빼는데 그냥 빼면은 이제 여기서 체어 빼기 블랙서클 이렇게 되는데 만약에 이제 절대값을 구하고 싶다.

차이의 절대값.

왜냐면 순서가 중요하거든요.

이렇게 하면 이쪽에서 이걸 빼는지 어느 빼는 순서가 중요한데 앱스 디프 하면은 앱스는 이제 앱솔루트 절대적인 차이거든요.

그래서 두 개의 절대값 이런 식이 돼서 뭐에서 뭘 빼는지 순서가 중요하지 않습니다.

그래서 이제 순서가 중요한 경우에는 요걸 쓰시면 되고요.

요거는 앞에서 뒤를 빼기 때문에 그래서 만약에 이제 막 그 어떤 경우가 생기냐면 이제 이 블랙서클 같은 경우는 블랙서클.

블랙서클 같은 경우는 가운데가 이제 까만색 동그라미거든요.

그럼 까만색이면 여기가 다 0이에요.

그리고 흰색은 255가 됩니다.

그러면 이 블랙서클은 어떻게 되냐면 요 테두리에 있는 데는 흰색이니까 빛의 밝기는 255보다 클 수가 없거든요.

그러면은 여기에서 의자를 빼면은 의자에 여기에 픽셀의 밝기가 얼마든지 간에 다 짤려 나갑니다.

그래서 요 가운데 부분만 남게 돼요.

말로 설명하면 좀 어려운데 그림으로 보시죠.

왜냐하면 흰색은 밝기가 255니까 이 의자 그림에 이 의자 이미지에 뭐가 있었던지 간에 이 오른쪽에서 255를 빼버리면 다 0보다 작아진단 말이에요

0이랑 같거나 잘해봐야 0보다 같거나 0보다 작아지게 됩니다

그래서 결국 이렇게 빼주면 뒷부분이 다 날라가 버립니다

그래서 이제 이렇게 알려주는 효과가 있고 이거는 순서를 반대로 하시면 아 빼기로 하면 되지 순서를 반대로 하면은 가운데가 이렇게 까맣게 나오고 바깥에가 약간 이상하게 이렇게 됩니다

빼는 순서가 중요하거든요

그래서 어디서 어딜 빼냐에 따라서 이렇게 다르게 되는데 앱스디프를 하시면은 이런 식으로 나온다

여기가 지금 보시면은 의자에서 이제 흰색에서 의자를 뺀게 되고 이거는 의자에서 까만색을 뺀게 되고 이런식으로 그래서 이미지 두 장을 빼는 거를 이렇게 해 보실 수 있고요

어 그 다음에 여기 의자 예를 들면 아까 제가 그냥 말로만 얘기 드렸는데 예를 들면 의자가 있는데 여기에 이제 누가 앉아있다 사람을 하나 사람을 하나 뼈다 그리 좀 여기다가 뭐 또 이렇게는 안되나 뭐 하여간 사람을 하나 사람을 뭐 이렇게 대충 그려가지고 다른 이름으로 저장을 해서 저 투 뭐 이런 식으로 저장을 해놓으면 잘 안보이시겠지만 사람이 앉아있다 칩시다

그러면은 그 두개를 빼면은 사람만 나오겠죠

왜냐하면 나머지는 똑같으니까 사람만 이렇게 나오게 됩니다

그래서 만약에 이제 chair1하고 chair1을 빼면 어떻게 되겠어요

아무것도 없겠죠

그냥 아무것도 없고 사람이 있을 때만 여기에 이제 뭔가가 찍히게 됩니다

그래서 만약에 이제 뭐 주변에 어떤 노이즈가 없고 카메라가 딱 고정되어 있는 상태에서 어디를 계속 찍고 있는데 사람이 있는지 없는지 알고싶다

근데 복잡한 알고리즘 쓰기가 싫다 그러면은 사람 말고는 이 화면에 잡힐게 없다 그러면 그냥 두개를 그냥 빼버리시면 제일 좋습니다.

제일 간단하게 탐지를 할 수 있습니다.

근데 이제 이거 문제는 뭐 예를 들면 쓰레기 같은게 바람이 휙 지나가면 그것도 뭐가 잡히겠죠

그래서 요즘에도 그걸 쓴지 모르겠는데 옛날에 휴전선 같은데 다 군인들이 볼 수가 없으니까 카메라로 이렇게 누가 넘어오는지 안 넘어오는지 하는데 그 알고리즘이 거의 이런 수준이여가지고 바람 불면은 뭐가 계속 알람을 울리고 멧돼지 지나가도 알람 울리고 뭐가 지나가기만 하면은 화면에 두개를 그냥 단순히 빼니까 차이가 나오는거에요

그래서 이제 그냥 아예 꺼놓고 안쓴다

뭐 이런 얘기가 있었는데 그런 외부 환경에서는 쓰면 안되겠죠

뭐가 휙 지나갈 수 있으니까 근데 이제 간단한 상황에서는 이렇게 해도 충분히 쓸 수 있다

조도가 변할때는 어떻게 해결해요?

조도가 변할때요?

아 밝기가 변한다

그쵸?

해가 떴다 그쳤다

이러면은 이제 또 골치 아프죠

사실은 단순한 알고리즘으로 다 해결하려고 하면은 좀 골치가 아플 수 있는데 뭐 그런 경우에도 해결할 방법이 있죠

그림판이라서 밝기 조절이 안되는데 그림을 두개를 이제 밝기를 조절을 해주는거에요

어떻게 하냐면 뭐 여러가지 방법이 있는데 여기서 평균 밝기를 일괄적으로 빼준다던지 그러면은 밝기를 이렇게 그 조도를 맞춰주는거죠

그 다음에 빼버리시면 됩니다

## 이미지 곱셈과 나눗셈

```python
cv2.multiply(image, 1.2)
```

자 그 다음에 이제 빼는것도 해봤으니까 곱셈 나눗셈도 하면 되겠죠

곱셈 나눗셈은 뭐 쉬운데 멀티플라이라던가 디바이드 이런 함수가 있어서 얘네도 어 그 이렇게 이 범위를 벗어나는걸 막아줍니다

오버플로우 언더플로우를 막아주고 그래서 이제 1.2를 곱해라 1.2를 곱했는데 그러면은 뭐 250 같은건 1.2 곱해버리면은 막 300 400 이렇게 되버리잖아요

그래서 255에서 막아줍니다

```python
cv2.divide(image, 1.2)
```

나눗셈도 마찬가지구요

```python
255 - image
```

그 다음에 이제 색을 반전시킬수도 있는데 색을 반전시킨다는거는 밝은거는 어둡게 만들고 어두운거는 밝게 만드는건데 어차피 제일 밝은게 255란 말이에요

그럼 255가 반전되면은 0이 되야겠죠

그래서 어떻게 하면 되냐면 그냥 255 빼기 하면은 색이 뒤집힙니다

그래서 밝은거는 어두워지고 어두운거는 밝아지고 이렇게 그래서 예를들면은 우리가 쇼우 체어 하면은 의자가 나오는데 255 빼기 체어 하면은 색깔이 초록색은 보라색이 되고 흰색은 검은색이 되고 이렇게 다 뒤집혀서 나오게 되죠

밝은데는 어두워지고 어두운데는 밝아지고 이렇게 되거든요

## 컬러 스페이스

자 그 다음에 이제 우리가 그 색을 표현하는 방법을 좀 알아보면 지금까지는 이제 우리가 rgb 또는 bgr을 쓰고 있는데 rgb 나 bgr 이나 그냥 순서의 차이 똑같은 겁니다

그 다음에 이제 hsv 로 색을 표현하는 방식도 있는데 hsv 는 색상 채도 명도 이렇게 나눠서 색상이 h 채도가 s 명도가 v 이렇게 표현하는 겁니다

그래서 여기 그림으로 나타내는게 여기 아래쪽에 있는 건데요 그래서 색상을 그 이렇게 그 색상환의 형태로 표현을 하고 그 다음에 이제 채도가 채도가 이제 그 밝은데서 탁한 것까지 이렇게 있고 그 다음에 이제 명도가 또 밝은 거에서 이게 밝고 어둡고 이렇게 조절을 하는 것 그래서 이거는 그 그냥 말로 하면은 좀 잘 감이 안 오고 구글에 가셔가지고 컬러 피커 라고 검색을 하시면 컬러 피커 구글에서 그 색상 선택 도구 라는게 뜨거든요

다 그래서 여기서 보시면은 이게 하단의 rgb 라 hsv 를 표시를 해 주는데 어 지금 hsv 를 보면 44도 99% 99% 이렇게 되겠죠

44도가 뭐냐면 색의 그 색상 환에서 색상을 이제 빨간색 부터 지금 빨간색으로 쭉 해본 빨간색 영도 요 빨간색 부터 시작해서 시계방향으로 뺀 그 색깔 들을 순서가 변화가 변화가 되는 것이고요 빨간색으로 쭉 해보면 빨간색이 0도에요 빨간색부터 시작해서 시계 방향으로 뺀 그 색깔 들을 순서대로 변화가 되는 것을 확인할 수 있어요 빨간색 부터 지금 빨간색으로 쭉 해보면 빨간색 0도에요 빨간색부터 시작해서 시계 방향으로 뺀 그 색깔 들을 순서가 변화가 되는 것을 확인할 수 있습니다.

색깔들을 순서대로 배치한 다음에 다시 빨간색으로 돌아오는 이런거고 그래서 이렇게 쭉 올리면 그 360도 까지 가면 다시 빨간색으로 돌아오는 거죠

이렇게 한 바퀴 돌면 그래서 이게 HSV에서 첫 번째 색상의 의미고 그 다음에 이제 두 번째는 Saturation 탁한 정도를 조절을 합니다

그래서 지금 여기 보시면은 색이 이렇게 내려가면 색이 탁해지죠

그래서 보면은 아 이거 이쪽이 아니라 이쪽으로 가야 되나 이쪽으로 가면 색이 탁해지죠

그래서 보면은 밝기는 거의 똑같은데 밝은 정도는 똑같은데 이제 색이 탁해지니까 Saturation이 떨어지는 걸 볼 수 있어요

그래서 쨍하게 빨간색이면 Saturation이 높은데 이렇게 탁한 밝은 색이면 밝기는 밝지만 명도는 높지만 Saturation이 떨어지는 거죠

채도가 떨어집니다

그 다음 맨 마지막이 이제 밝기인데 밝기는 말 그대로 이제 여기 밝으냐 어두우냐

이거죠

이거는 밝은 거 이거는 어두운 거 이렇게 옮겨 보시면은 여기 보면은 요거를 옮겨 보시면은 지금 여기 제일 오른쪽에 있는 세 번째 숫자가 바뀌는 거를 볼 수 있죠

근데 이제 알게 되면은 이게 이제 밝은 색이 떨어지는 거죠

그래서 RGB로 이제 조합을 하면은 굉장히 숫자가 복잡합니다

사실 HSV는 우리가 좀 직관적으로 H가 약간 좀 잘 안 와닿긴 한데 S랑 V는 사실 우리가 이해하기 쉽거든요

그래서 이렇게 옮겨 보시면 지금 보시면 이제 V만 바뀌는데 RGB에선 숫자가 세 개가 다 바뀌거든요

그렇겠죠

왜냐하면은 그래서 이제 요거를 이제 색깔을 여러 개를 좀 이렇게 옮겨 보시면서 HSV랑 RGB랑 RGB랑 이렇게 옮겨 보시면은 이제 이렇게 색깔을 여러 개를 좀 이렇게 옮겨 보시면서 그래서 이제 요거를 이제 색깔을 여러 개를 좀 이렇게 옮겨 보시면서 이렇게 상태가 어떻게 바뀌는지 한번 보시면은 될 거 같고요 이렇게 상태가 어떻게 바뀌는지 한번 보시면은 될 거 같고요 이렇게 상태가 어떻게 바뀌는지 한번 보시면은 될 거 같고요 그래서 이제 OpenCV에서도 색깔을 색갈 공간을 바꿀 수가 있는데 우리가 이제 그 bgr 에서 흑백으로 바꾸려면 bgr2 gray 이렇게 하면 되고 흑백에서 bgr 로 바꾸려면 gray2 bgr 하면 되는데 이렇게 하면 그냥 숫자가 3배로만 늘어납니다

왜냐면 어차피 원래 회색이었기 때문에 원래 색깔이 없어요

그럼 bgr 로 나타내도 회색은 회색이겠죠 단지 이제 bgr 에서는 회색을 나타내려면 색깔 3개를 1대1대1로 섞어야 회색이 되기 때문에 그냥 예를 들면 원래 밝기가 50 이었다

bgr 로 바꾸면 그냥 50 50 50 이렇게 됩니다

b가 50, g가 50, r이 50 그래서 숫자만 늘어나고 실제 눈에 보이는 색은 똑같아요

그 다음에 bgr 에서 hsv 로 바꾸시려면 bgr2 hsv 이렇게 하면 hsv 의 숫자가 3개가 똑같이 있는데 bgr 이 아니라 hsv 가 됩니다

그래서 hsv 로 바꾸면 뭐가 좋냐

예를 들면 색의 밝기만 전반적으로 올리고 싶다든지 채도만 전반적으로 올리고 싶다든지 색의 밝기만 전반적으로 올리고 싶다든지 채도만 전반적으로 올리고 싶다든지 채도만 전반적으로 올리고 싶다든지 만족을 하고 싶다든지 이럴 때는 bgr 에서는 예를 들어서 밝기를 조절하려면 이게 좀 복잡하거든요

복잡한데 hsv 에서는 그냥 맨 마지막 숫자만 올려 주면 됩니다

그래서 좀 더 간단해진다고 할 수 있죠


BGR에서 흑백으로
```python
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
```

흑백에서 BGR로(눈에 보이는 색은 바뀌지 않음)
```python
cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)
```
BGR에서 HSV로
```python
hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
```

## 채널 분리

아 아 자 그 다음에 아 우리가 이제 또 재밌는 걸 하나 해보면 원래 이제 이미지는 4 지금 쇼 이미지 해보면 이제 이런 그 빠 hyung 파랑 노랑 초록이다

```python
b, g, r = cv2.split(image)
```

이렇게 있는데 여기에서 우리가 이제 bg 알 채널 중에서 블루 채널만 뽑아 가지고 보고 싶다 그럴 수가 있겠죠

이미지에서 채널을 분리를 하면 됩니다

그러면 이제 B.Shape 해보시면은 아까 Image.Shape은 Image.Shape은 1024, 1024, 1024, 1024, 1024, 1024, 1024 해서 3개의 채널이 다 있었는데 지금 BGR을 분리를 하면은 B.Shape 해보면 1024, 1024 이렇게 돼 있어요 숫자가 300만 개였는데 100만 개로 줄었죠

왜냐면 채널 하나만 있으니까 그래서 이 B채널만 보려면 이거는 Show 함수를 쓰시면 안 되고 왜냐면 Show 함수 만들 때 받는 이미지가 BGR로 돼 있다고 가정을 하고 만들었는데 이 B는 지금 BGR이 아니에요

그죠?

그냥 B 하나만 있는 거죠

```python
Image.fromarray(b)
```

그래서 이제 이렇게 보시면 지금 여기가 까맣고 여기가 흰색으로 나오는데 여기가 실제로는 흰색으로 나오는데 흰색이 아니라 무슨 색이냐 하면 파란색이죠

여기는 파란색 성분이 없어요 빨간색, 노란색 밖에 없거든요

그러니까 노란색은 초록색이랑 빨간색이랑 섞은 게 노란색이죠

여기는 파란색이 없습니다

그래서 이제 파란색이 없는 데는 까맣게 나오고 파란색이 있는 데는 하얗게 나오고 이렇게 됩니다

그래서 반대로 이제 알 같은 걸 보면은 하늘 있는 데가 검은색이 나오죠

왜냐면 하늘에는 빨간색이 있는데 하늘에는 빨간색이 거의 없어요

하늘은 대부분 파란색 성분입니다

그리고 풍선에서도 가운데가 까맣고 위아래가 하얗게 나오죠

하얗게 나온 데가 실제로 빨간데고 그렇습니다

근데 이제 이렇게 보면은 사실 이제 말로 설명하니까 알겠는데 직관적으로는 좀 잘 안 와닿거든요

```python
z = np.zeros_like(b)
show(cv2.merge((b, z, z)))
```

일단 이 mp.zeroth-like 하면은 b랑 똑같이 생긴 0으로 가득찬 배열을 하나 만들어 줍니다

그러니까 요 크기랑 똑같은 0으로 가득 찼다는 건 다 검은색이라는 얘기죠

그래서 z는 그냥 크기가 똑같고 다 까매요

그래서...

merge라는 거는 이제 채널을 합쳐 주는 건데 b, g, r 이렇게 합치면은...

이렇게 하면은 b, g, r을 합치면 다시 원본대로 돌아오는데 g하고 r을 z로 바꿔주면 초록색하고 빨간색 성분은 없애버리는 거죠

파란색 성분만 남기는 겁니다

그러면은 실제로 파란색이 어떻게 있는지를 우리가 볼 수 있습니다

원래 이미지에서 파란색을 더 씌운 게 아니라 원래 이미지에서 파란색만 뽑아낸 거예요

그럼 초록색만 뽑아내려면 어떻게 하면 될까요?

여기를 b를 z로 바꿔주고 두 번째만 g로 하면은 파란색이랑 빨간색은 날려버리고 초록색만 남길 수 있습니다

그럼 이렇게 하면 여기가 이제 초록색만 있는 거죠 빨간색만 남기려면 맨 마지막에 r 이렇게 남겨주시면 빨간색만 남기 때문에 이렇게 됩니다

그래서 이게 이제 슬라이드 51쪽 내용이에요

부분이 되는 거죠

## 특정 색상만 추출

```python
lower = np.array([40, 50, 50])
upper = np.array([80, 255, 255])
mask = cv2.inRange(hsv, lower, upper)
Image.fromarray(mask)
```

그리고 만약에 노란색만 뽑고 싶다 그러면 노란색이 이제 노란색이 여기서 보면 어느 정도입니까

한 20부터 한 40까지 요 사이가 노란색으로 보이죠

노란색만 뽑고 싶다

그러면 어떻게 되겠어요

여기 40에서 80이 아니라 한 20에서 40 이렇게 하면은 노란색 있는데만 이렇게 하얗게 됩니다

노란색이 없는 데는 안나오고 근데 이제 이렇게 하면은 그 노란색이 있는 데가 하얗게 나오고 노란색이 없는 데는 까맣게 나오니까 약간 그 실제 이미지 하고 좀 다르잖아요

```python
cv2.bitwise_and(image, image, mask=mask)
```

그래서 이제 실제 이미지처럼 그 하려면 어떻게 하면 되냐면 이렇게 비트와이즈 엔드 라는 것을 쓰면 되는데요 이건 여기다 이제 쇼우를 붙여야 화면에 표시가 되요 보시면은 원래 이미지에서 노란색인 부분만 이렇게 딱 잘라 내줍니다

특정 색인 부분만 그리고 비트와이즈 엔드는 이제 뭔지 좀 있다 얘기 드리고 이렇게 해서 우리가 특정 색깔인 부분만 딱 잘라낼 수가 있어요

그래서 뭐 요것도 이제 그 여러가지 여러가지 용도로 쓸 수 있는데 예를 들면 우리가 크로마키라고 해서 뒷배경에 초록색이나 파란색 천을 놓고 사람 합성할 때 그렇게 하잖아요

그럼 어떻게 하면 됩니까?

파란색 그 범위를 잡아가지고 파란색 색상 범위를 날려버리면 되겠죠

그래서 크로마키 같은 거 할 때 이렇게 사람 세워놓고 이 뒤에 초록색을 날려버리고 싶을 때 초록색의 H 범위를 잡아가지고 그냥 날려버리면 사람만 딱 따낼 수가 있습니다

그림 하단에 보면 숫자가 이렇게 써 있습니다.

이게 H색깔이거든요.

H 숫자거든요.

사실 노란색이라는 게 딱 끊어지는 게 아니라 주황색부터 연두색까지가 노란색이잖아요.

그래서 여기 숫자를 보시면 여기 보통 대충 한 20에서 40 사이 정도가 노란색이고 40에서 넓게 잡으면 한 80?

아니면 70 이 정도가 초록색이고 그다음에 파란색은 한 90에서 130?

네.

30 이 정도가 이건 이제 뭐 딱 정확하게 얼마다

이런 건 없으니까 이거 이제 눈으로 보시고 이 숫자에서 원하시는 색상 범위를 여기 보시면 지금 40에서 80 돼 있으니까 이 코드는 여기서부터 여기까지를 잘라주는 색깔을 뽑아주는 코드입니다.

## 이미지에 빨간 점 하나 찍기

```python
dup = image.copy() # 복사
center = 100, 100 # 중심 좌표
radius = 10 # 반지름
color = 0, 0, 255 # 색상
thickness = -1  # 두께 설정 (-1은 채워진 원을 의미)
cv2.circle(dup, center, radius, color, thickness)
```

여기서 이제 비트와이즈의 엔드라는 게 나오는데 이게 뭔지를 알기 위해서 우리가 일단 이미지에다가 빨간 점을 하나 찍어보겠습니다.

이게 그림판에서 찍어도 되는데 코드를 한번 찍어볼 거예요.

코드 설명을 먼저 드리면 여기 이미지 점 카피 이러면 이제 복사를 합니다.

그래서 듑이라는 거를 복사를 해놓고 이 듑에다가 100,100 위치에 반지름 10이고 색깔은 BGR이니까 빨간색이겠죠.

빨간색으로 원을 그리는데 여기 Thickness는 이제 원 테두리 두께입니다.

그래서 이거를 예를 들면 1이라고 하면 이렇게 얇게 그리고 10이라고 하면 이렇게 두껍게 그리는데 마이너스 1이면 꽉 차게 그려요.

그래서 마이너스 1이라고 했으니까 반지름이 10이고 빨간색인 꽉 찬 원을 그리라는 거죠.

어디에?

100,100에다.

그래서 이렇게 하면은 이 듑에 네.

이렇게 그려지거든요.

그래서 Show, 듑 해보면 여기에 지금 빨간 원이 이렇게 그려져 있죠.

그러면 원본하고 듑의 차이는 여기 빨간 원 하나 찍힌 거와는 다른 거죠.

안 찍힌 거 그 차이밖에 없잖아요.

그렇죠?

원본은 원본은 여기 빨간 원이 없고 듑은 여기 빨간 원이 하나 있고 이렇게 차이가 있습니다.

## 비트와이즈 연산

AND: 두 이미지의 비트에 대해 AND(둘 다 1일 때만 1)
```python
cv2.bitwise_and(image, dup)
```
OR: 두 이미지의 비트에 대해 OR(둘 중 하나라도 1이면 1)
```python
cv2.bitwise_or(image, dup)
```
XOR: 두 이미지의 비트에 대해 XOR(둘 중 하나만 1이어야 1) → 다른 부분 찾기
```python
cv2.bitwise_xor(image, dup)
```

그러면은 다음 장으로 넘어가서 이제 원본 이미지랑 듑을 가지고 비트와이즈 연산을 할 수 있는데 비트와이즈 연산은 뭐냐면 우리 논리에서 말하는 AND, OR, XOR 이런 거를 하는 겁니다.

AND는 뭐예요?

AND는 참일 때만 참이고 하나라도 거짓이면 거짓이 되죠.

둘 다 거짓이면 당연히 거짓이고 그래서 참이라는 건 여기서 1, 2, 3 이런 숫자고 거짓은 0으로 칩니다.

일반적으로 프로그래밍에서 0은 거짓으로 치거든요.

그래서 이제 비트와이즈 AND라고 하면은 둘 다 참인 거 그러니까 둘 다 뭔가 검은색이 아니어야 돼요.

둘 다 뭔가 색깔이 있어야 됩니다.

그 다음에 OR는 뭐냐면 둘 중에 하나만 뭔가 색깔이 있으면 됩니다.

그러면은 있는 걸로 치는 거예요.

그 다음에 XOR는 뭐냐면 둘 다 색깔이 있으면 안 되고 하나가 색깔이 있으면 하나는 색깔이 없어야 돼요.

그런 식으로 되죠.

XOR가 되고 그래서 아까 여기 보면은 AND를 했잖아요.

AND는 둘 다 색깔이 있어야 되는데 이렇게 이미지, 이미지 하면은 어차피 둘 다 색깔이 있으니까 통과인데 여기 마스크가 있어가지고 마스크가 이 범위에서만 마스킹을 하기 때문에 그 마스크가 흰색인 부분만 뽑혀져서 나오게 돼요.

그래서 우리가 이제 듀브를 가지고 이렇게 한번 해보면 CV2.bitwise AND 한 다음에 원본이랑 복사본이랑 이렇게 하면은 결과가 나오는데 이 결과가 이제 숫자로 나오면은 SHOW 함수를 한번 써주시면 됩니다.

그러면은 여기 빨간색 있는데만 약간 색깔이 좀 다르게 나오고 나머지는 뭐 똑같이 나오죠.

그 다음에 이제 OR로 해보면은 그 다음에 이제 OR로 해보면은 XOR로 하면은 이 두 개가 거의 똑같아요.

왜냐하면은 기본적으로 더한 거랑 비슷하다고 생각하시면 됩니다.

OR는 근데 XOR를 하면 이 빨간 점 있는 데만 나오고 나머지는 다 검은색이 됩니다.

왜냐하면 XOR는 둘 중에 하나만 참여해야 돼요.

그러니까 우리가 수학 시간에 배우는 OR하고 일상적인 OR하고 다른데 수학 시간에 배우는 OR는 예를 들면 짜장면 OR 짬뽕 이렇게 말하면 짬짜면도 되는 거죠.

둘 다 먹어도 됩니다.

그죠?

둘 다 참여해도 참여해.

근데 우리가 일상에서의 OR는 짜장면 또는 짬뽕이라고 하면 짜장면을 먹든 짬뽕을 먹든 둘 중에 하나만 먹어야지.

예를 들면 식당에 후식으로 짜장면을 먹으면은 짜장면 OR 짬뽕을 드립니다.

둘 다 먹으면 안 되나요?

그러면 사장님이 안 됩니다.

이렇게 얘기하겠죠.

일상에서 말하는 OR는 둘 중에 하나만 되는 거예요.

그래서 이 일상에서의 OR는 수학에서 XOR라고 해요.

왜 XOR라고 하냐면 Exclusive OR에서 배타적 OR, 배제적 OR 그러니까 둘 다는 안 됩니다.

그래서 여기서 이제 Bitwise XOR 하면은 둘 다 색깔이 있으면 안 돼요.

둘 다 같은 색이면 안 되고 하나가 여기는 빨간색이 있었고 하나는 없었고 그럼 그 차이가 나는 부분만 찾아줍니다.

그래서 이렇게 하면은 둘이 차이가 나는 부분만 찾아주게 돼요.

그래서 이렇게 하는 것이 이제 Bitwise 연산이다.

이런 겁니다.

아 여기가 왜 빨간색이 아니냐고요?

그게 약간 색깔이 지금 완전 순도 여기 있는 빨간색이고 이게 어 이게 Bit 현산이라서 사실 딱 그 색깔만 있는 데를 뽑는 건 또 아니에요.

약간 복잡한데 실제로는 이제 정말 비트 단위로 계산하는 거거든요.

그래서 이거는 예를 들면은 이렇게 하면은 이렇게 하면은 이렇게 하면은 예를 들면은 어떻게 해야 되나?

어 지금 보시면은 여기 왼쪽은 123이고 오른쪽은 024인데 요걸 두 개를 XOR를 하면은 1하고 0은 1이 되고 2하고 2는 0이 되고 3하고 4는 7이 되고 3하고 4는 7이 되고 7이 되고 아 이렇게 하면 3하고 4로 하면 안 되겠구나.

여기를 2로 해야겠다.

어?

2로 하면 안 되나?

잠깐만요.

제가 이거 헷갈리는데 왜 그러냐면 이게 이제 Bit 단위로 연산을 하니까 이게 2진수로 이게 좀 설명하면 복잡한데 2진수로 할 때 4는 4는 얼마죠?

1 0 0이잖아요.

그리고 아 여기를 하나를 5로 해야겠구나.

그러면 되나?

5로 하면 1이 되겠죠.

왜 1이 되냐면 4는 1 0 0이 되니까 4는 1 0 0이 되니까 4는 1 0 0이 되니까 4는 1 0 0이 되니까 4는 1 0 0이 되니까 4는 1 0 0이 되니까 4는 1 0 0이 되니까 2 중에 하나만 1인데가 여기만 둘 중에 하나가 1이잖아요.

나머지는 같으니까 그러면 0 0 1 이렇게 됩니다.

그래서 약간 좀 복잡한데 그 정말로 눈에 보이는 색깔이 다른 부분을 찾는 게 아니라 정말 2진수의 Bit가 다른 부분을 찾는 거예요.

그래서 아 그래서 2진수의 Bit가 다른 부분을 찾는 거예요.

그래서 2진수의 Bit가 다른 부분을 찾는 거예요.

```python
diff = cv2.bitwise_xor(image, dup)
diff = cv2.cvtColor(diff, cv2.COLOR_BGR2GRAY)
show(cv2.bitwise_and(dup, dup, mask=diff))
```

질문하신게 정확하게 빨간색으로 뽑아내려면 어떻게 하느냐 일단 원본하고 엑소로 하면 차이를 구하는데 차이가 비트 단위의 차이입니다.

사실 1비트 정도는 같아도 되는데 그런것까지 다 빼니까 아까 해보면 색깔이 빨갛게 안나오고 분홍색으로 나왔단 말이에요.

그래서 어떻게 하냐면 일단 차이를 구한 다음에 그 차이를 흑백으로 바꿉니다.

그러면 차이가 있는 부분은 하얗게 되고 차이가 없는 부분은 디프만 보면 보면 여기가 회색으로 나오죠.

근데 이제 그러면 어떻게 하면 되냐면 여러가지로 해결을 할 수 있는데 엔드를 한 다음에 듑하고 듑을 엔드를 한 다음에 어차피 엔드하면 결과가 똑같아요.

그래서 사실 이 엔드나 별로 의미 없는게 아니고 여기다가 마스크를 씌워주면 어떻게 되냐면 여기 뭐라도 색깔이 있으면 그 부분만 통과를 시켜줍니다.

까만 부분은 막아주고 그래서 이 마스크가 하는 역할은 검은색이 있는데는 막아주고 색깔이 있는 부분은 통과를 시켜주고 그래서 듑에서 빨간부분만 통과를 시켜줘요.

이렇게 해서 diff에 조금이라도 색이 있는 부분만 이렇게 해서 보기 이렇게 하시면 이제 두 개의 차이를 구해가지고 두 개에서 1비트라도 뭔가 다른 부분을 원본 색상 그대로 이렇게 볼 수가 있습니다.

