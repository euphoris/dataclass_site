# 테스트

## 과소/과대 적합
*   과소적합(underfitting): 실제 패턴보다 모형이 단순
*   과대적합(overfitting): 실제 패턴보다 모형이 복잡

## 데이터 분할
*   데이터를 Training과 Testing으로 분할 (보통 8:2 또는 9:1)
*   파라미터를 추정하는데는 많은 데이터가 필요하므로 Training을 크게
*   Testing은 모형들의 성능을 구별할 정도만 되면 충분하므로 작게
*   Training에 과적합되면 Testing에서 성능이 낮아짐
*   Training과 Testing의 데이터가 섞이지 않도록 유의

## 과적합의 진단
*   training set에서는 성능이 높지만 testing set에서는 성능이 낮을 경우
    *   → overfitting 되었을 가능성이 높음
    *   → 모형의 복잡도를 낮추는 방향으로 구조/하이퍼파라미터를 조정
*   training set에서도 성능이 낮을 경우
    *   → underfitting이 되었을 가능성이 높음
    *   → 모형의 복잡도를 높이는 방향으로 구조/하이퍼파라미터를 조정

## 테스트
테스트 데이터 뽑기
```python
x_test_binary, y_test_binary = filter_binary(x_test, y_test, 0, 1)
```

평가
```python
model.evaluate(x_test_binary, y_test_binary)
```


## 직접 손글씨 입력해보기
*   그림판에서 직접 손글씨 입력
*   크기 조정(픽셀, 28, 28, 가로세로 비율 X)
*   오른쪽 하단 확대/축소로 확대
*   색 채우기 (검은색)
*   브러시(색 1 → 흰 색)
*   검은 바탕에 흰 글씨로 0 또는 1
*   hand.png로 저장

## 손글씨 이미지 불러오기
```python
import cv2 as cv
x = cv.imread('data/hand.png', cv.IMREAD_GRAYSCALE) # 이미지 불러오기
x = np.expand_dims(x, axis=0) # 배치 차원 추가
model.predict(x) # 예측
```

## 차원의 추가 방법들
*   expand_dims
    ```python
    np.expand_dims(x, 0) # 0번 차원 확장
    ```
*   new_axis
    ```python
    x[np.newaxis, 0:28, 0:28] # 0번 차원에 새 축, 1, 2차원은 0~28번값
    x[np.newaxis, :, :] # 0번 차원에 새 축, 1, 2차원은 모든 값
    x[np.newaxis, ...] # 0번 차원에 새 축, 다른 차원은 모든 값
    ```
*   reshape
    ```python
    x.reshape(1, 28, 28) # 모양을 1, 28, 28로 변경
    ```


## 퀴즈

import { QuizComponent } from "@/components/QuizComponent";

<QuizComponent quizId="test-set" quizItems={
[
    {
        "item_type": "checkbox",
        "question": "과대적합에 대한 설명으로 올바른 것을 모두 고르세요",
        "options": [
            "실제 패턴보다 모형이 복잡할 때 생긴다",
            "training set에서만 성능이 높게 나온다",
            "test set에서 성능이 높게 나온다",
            "모형의 복잡도를 낮추는 방향으로 구조나 파라미터를 조정한다"
        ],
        "hint": "모델이 학습 데이터의 노이즈까지 암기하여 새로운 데이터에 대한 일반화 성능이 떨어지는 현상입니다.",
        "solution": [
            "실제 패턴보다 모형이 복잡할 때 생긴다",
            "training set에서만 성능이 높게 나온다"
        ]
    },
    {
        "item_type": "radio",
        "question": "파일에서 불러온 단일 이미지를 모형에 입력하기 전에 배치(batch) 차원을 추가해주는 이유는 무엇입니까?",
        "options": [
            "이미지의 해상도를 높이기 위해",
            "모델이 처리할 수 있는 입력 형태를 맞추기 위해",
            "이미지를 흑백으로 변환하기 위해",
            "모델의 학습 속도를 높이기 위해"
        ],
        "hint": "딥러닝 모델은 일반적으로 한 번에 한 장이 아닌 여러 장의 이미지를 묶음(batch)으로 처리하도록 설계되었습니다.",
        "solution": "모델이 처리할 수 있는 입력 형태를 맞추기 위해"
    },
    {
        "item_type": "radio",
        "question": "분류 모델에서 model.predict()의 결과값이 의미하는 것은 무엇입니까?",
        "options": [
            "모델의 최종 학습 정확도",
            "입력된 데이터가 클래스 0에 속할 확률값",
            "입력된 데이터가 클래스 1에 속할 확률값",
            "모델 학습이 완료되었음을 알리는 신호",
            "가장 확률이 높은 단 하나의 클래스 이름"
        ],
        "hint": "모델은 예측 결과를 확률의 형태로 출력하며, 가장 높은 확률을 가진 클래스를 최종 예측으로 선택합니다.",
        "solution": "입력된 데이터가 클래스 1에 속할 확률값"
    }
]    
} />


## Q&A
<iframe src="https://tally.so/embed/wbOOKg?alignLeft=1&hideTitle=1&transparentBackground=1&dynamicHeight=0" loading="lazy" width="100%" height="274" frameborder="0" marginheight="0" marginwidth="0" title="Q&A"></iframe>