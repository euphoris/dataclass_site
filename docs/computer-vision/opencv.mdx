# OpenCV 기초

## OpenCV 소개

그래서 이제 OpenCV 는 어 우리 앞에서 봤던 PIL 은 아주 그냥 기본적인 이미지 파일 열고 닫고 뭐 이 정도의 처리를 한다면 OpenCV 는 진짜 컴퓨터 비전을 하기 위한 라이브러리 입니다

그래서 이제 어떤 전통적인 영상 처리 이 를 중심으로 해서 컴퓨터 비전 관련된 기능을 제공하고 여기서 제공하는 기능이 2500개가 넘어요

제가 이제 마지막으로 확인했을 때가 2500개 였고 지금은 더 많을 수도 있죠

계속 버전이 올라가니까 그래서 사실 OpenCV 에 있는 모든 기능을 공부하겠다 라는 것은 어 저도 잘 모릅니다

무슨 기능이 있는지 하도 기능이 뭐가 많아가지고 사실은 검색을 그래서 해보셔야 되요

OpenCV 로 뭐 하는 법 이런거는 이제 근데 어지간한 것은 있으니까 여러분들이 뭐 궁금하다

그러면 이제 검색을 해 보시면 되고 그 다음에 기본적으로 c++ 라는 언어로 작성이 되어 있습니다

c++ 는 좀 속도가 빠른 그런 언어에요

그래서 여러분이 파이썬으로 작업을 하시더라도 실제로 대부분의 복잡한 작업은 c++ 그 c++ 그냥 줄여서 보통 c++ 이라고 하는데 c++ 로 되어 있기 때문에 속도가 굉장히 빠른 언어로 작성되어 있습니다.

그래서 여러분이 파이썬으로 작업을 하시더라도 실제로 대부분의 복잡한 작업은 c++ 그 c++ 그냥 줄여서 보통 c++ 이라고 하는데 c++로 되어 있기 때문에 속도가 굉장히 빠릅니다

그래서 어 이만큼의 작업이 있으면 마큼은 대부분은 사실 그 c++ 로 돼 있고 우리 눈에 보이는 부분만 조금 파이썬으로 되어 있어요

그래서 그냥 100% c++ 로 하는거랑 속도 차이도 거의 안 납니다

어차피 이 부분은 이만큼만 속도가 느린 거라서 그래서 솔직히 뭐 OpenCV 로 하는 작업을 내가 빨리 하겠다고 파이썬에서 c++ 로 바꿔봤자 어차피 원래 c++ 로 돼 있는 거라서 딱히 더 빨라지지도 않아요.

이미 빠릅니다.

속도도 빠르고요.

우리는 파이썬에서 쓰는데 자바라든가 메틀랩이라든가 씨샵이라든가 어지간히 우리가 통상적으로 쓰는 언어는 다 이렇게 씨쁠뿔 파이썬 씨쁠뿔 자바 씨쁠뿔 씨샵 이런식으로 만들어져 있어서 여러분들이 파이썬으로 배우셨어도 다른 언어로 바꿔서도 거의 똑같이 사용을 하실 수 있거든요

그래서 현업에서 예를 들면 나는 자바 쓰는데 그래도 우리 수업에서 배운 것을 거의 그대로 약간 함수 모양만 좀 다르고 거의 똑같이 쓰실 수 있으니까 뭐 상관없다.

씨쁠뿔 쓰시는 분이면 그냥 씨쁠뿔로 쓰셔도 되겠죠.

그래서 여러가지 이미지 처리를 할 수 있고 그래서 우리가 딥러닝 모델을 직접 만드는 경우가 아니면 거의 오픈CV로 해결이 됩니다.

모델을 직접 만드셔야 된다.

그러면 우리가 후반부에 배울 파이토치 모델을 직접 만드셔야 되겠지만 그냥 있는 기능 있는 알고리즘으로 하고 싶다.

오픈CV로 하시면 됩니다.

## OpenCV 설치

그래서 설치를 하셔야 되는데 설치를 하는 방법이 두 가지가 있어요.

그래서 이제 그 아나콘다라고 돼 있는 게 있고 PIP라고 되어 있는 게 있는데 아나콘다는 뭐냐면 우리가 파이썬을 설치를 할 때 이제 그냥 파이썬 순정 버전으로 설치할 때가 있고 우리 자동차 같은 거 사도 이렇게 옵션을 끼워 주잖아요.

그래서 이 아나콘다는 뭐냐면 우리가 그냥 파이썬을 설치해서 쓰면은 약간 여러 가지 툴들이 있습니다.

우리가 지금 쓰고 있는 주피터 노트북이라든지 또는 뭐 여러 가지 툴들이 있는데 이거를 일일이 설치하려면 너무 번잡하기 때문에 이걸 다 묶어 놓은 일종의 패키지 상품 같은 거예요.

그래서 아나콘다를 깔면 파이썬도 깔리고 주피터도 깔리고 뭐 기타 등등 기타 등등 다 깔아줍니다.

그리고 만약에 추가로 필요한 게 있으면 conda install이라는 명령으로 추가로 깔 수 있게 해줘요.

PIP는 뭐냐면 이거는 파이썬 순정 버전에 있는 겁니다.

파이썬 순정 버전.

그래서 파이썬 순정 버전을 깔면은 이 PIP라는 프로그램으로 추가 라이브러리를 설치하거나 제거하거나 할 수 있습니다.

파이썬 순정 버전은 이 PIP라는 프로그램으로 추가 라이브러리를 설치하거나 제거하거나 할 수 있습니다.

사용법이 비슷합니다.

여기 시작 버튼 누르시면 오른쪽 상단에 모든 앱이라고 있거든요.

모든 앱을 누르시면은 모든 앱을 누르시면은 여기에 보시면은 여기 아마 아나콘다3라고 이렇게 있을 거예요.

그거를 눌러 보시면은 여기 보시면은 이렇게 되거든요.

거기에 세 번째 그 주피터 노트북이 네 번째 주피터 노트북이 있고 그 위에 보시면 아나콘다 프롬프트라고 있습니다.

파워셀 프롬프트도 상관없는데 아나콘다 프롬프트를 눌러 주십니다.


아나콘다 
```bash
conda install -c conda-forge opencv 
```
pip 
```bash
pip install opencv-python
```

## 파일 열기


임포트
```python
import cv2 
```

자 그래서 이제 파일을 열어 볼 건데 뭐 사용하는 방법은 비슷해요

```python
image_path = 'balloon.webp'
image = cv2.imread(image_path)
```

그래서 기본적으로 뭐 비슷하고 함수 이름이나 이런게 조금씩 다른데 OpenCV 에서는 그 파일을 불러오는 함수가 im read 입니다

이미지를 read 읽는다

이런 얘기죠

그래서 여기다 괄호하고 파일 이름을 써 주시면 되는데요 여기서는 파일 이름을 변수에 넣어두고 그 변수로 불러왔어요

비슷하죠

```python
image.shape
```

비슷하고 그 다음에 이미지 크기를 보는 방법이 PIL하고 좀 다른데 image.shape 이런식으로 불러오게 됩니다

그래서 이 그림은 1024, 1024, 3 이렇게 세 개 이런 형태로 배열이 되어 있는 숫자들이다.

이런 얘기가 되고요.

## 이미지를 이루는 점의 개수

```python
image.size
```

그래서 이 이미지를 이루는 점의 갯수, 총 점이 몇 개냐 하면 숫자 세 개로 곱하면 되겠죠.

1024 곱하기 1024 하면 백만 몇 개가 될 거고요.

100만 몇 개가 될 거고요.

거기다 곱하기 3을 했으니까 300만 몇 개 이렇게 나올 겁니다.

그래서 여기서 이미지점 사이즈 하면 그림의 크기를 알려주는 게 아니라 크기라면 크기인데요.

그 그림을 이루는 숫자의 총 개수가 나옵니다.

그러니까 314만 5728개의 점으로 이루어진 그림이다.

여기서 말하는 사이즈는 우리가 일반적으로 말하는 이미지 크기가 아니고 크기라면 크기지만 이미지를 이루는 점의 개수가 됩니다.

그 다음에 직접 계산을 해볼 수도 있는데요.

```python
image.shape[0] * image.shape[1] * image.shape[2]
```

우리가 이미지점 쉐입이라고 해보면 숫자가 3개가 나오죠.

그럼 이 숫자 하나하나를 가리킬 수가 있어요.

어떻게 가리키냐면 번째를 붙일 수 있는데 우리가 파이썬은 숫자를 셀 때 0부터 셉니다.

그래서 첫 번째가 아니고 0번째가 돼요.

0번째, 1번째, 2번째 이렇게 돼요.

그래서 몇 번째를 나타낼 때는 각과로 하고 0, 이렇게 하면 0번째를 말해요.

그래서 실행을 해보시면 1024가 나오죠.

그리고 여기다가 1

이렇게 보면 1번째가 돼서 또 1024고요.

2 하면 3이 나와요.

그러면 이거 3개를 곱해도 점의 개수가 나오겠죠.

그래서 똑같은 숫자가 나옵니다.

314만 5728개.

이게 37쪽의 두 번째 줄 내용입니다.

이렇게.

```python
import numpy as np
np.product(image.shape)
```

그래서 이렇게 계산을 해볼 수도 있고 그 다음에 이제 우리가 지금 이 이미지가 여기 이미지가 이 이미지가 어레이라는 형태로 되어 있는데 이 어레이에 있는 어떤 숫자들을 다루는 라이브러리가 있습니다.

여기 numpy라고 되어 있는데요.

numpy라는 게 이름부터가 numpy죠.

그러니까 어떤 파이썬에서 수학 계산 이런 거를 해주는 라이브러리입니다.

numpy는 설치가 되어 있어요.

numpy를 임포트해서 가져오면 되는데 보통 관습적으로 numpy가 이름이 너무 기니까 numpy라고 줄여서 부릅니다.

여기 as라고 하면 뭐라고 불러라

이런 얘기입니다.

그래서 원래 이름은 numpy지만 나는 mp라고 줄여 부르겠다.

보통 이제 약칭을 붙일 때 많이 쓰는데 numpy를 약칭을 nu라고 하셔도 되고 np라고 하셔도 되고 ny라고 하셔도 되고 마음대로지만 보통 이렇게 좀 널리 사용되는 라이브러리는 다들 줄여 부르는 이름이 있어요.

널리 사용되는 라이브러리는 다들 줄여 부르는 이름이 있어요.

널리 사용되는 라이브러리는 다들 줄여 부르는 이름이 있어요.

우리 뭐 영어로 이렇게 약자로 부를 때 예를 들면은 우리 회사 같은 데서 presentation한다고 안 하고 보통 pt한다

이러잖아요.

presentation인데 pr이라고 하면 안 되나요?

상관없습니다.

줄여 부르더라도 남들이 줄여 부른대로 불러야 혼동의 여지가 없겠죠.

이건 문법적인 거나 이런 건 아니고 그냥 일반적으로 numpy는 np로 불러야죠.

np라고 줄여 부릅니다.

그래서 줄여 부르는 건 여러분 마음인데 문법은 edge까지는 문법인데 np라고 하는 건 여러분 마음입니다.

아예 그냥 안 줄여 부르셔도 돼요.

하시면 그냥 계속 full name으로 부르시면 됩니다.

그렇지만은 남들 하는 대로 하는 게 좋은데 왜냐하면 우리가 코딩을 할 때 보통 코딩을 직접 하는 일이 그렇게 많지가 않아요.

생각보다 대부분 인터넷에서 검색해 가지고 코드를 갖다 붙이거나 아니면은 chat gpt 같은 걸로 물어봐 가지고 하거나 그 다음에 조금 고치는 경우가 많은데 남들이 다 np라고 줄여 부르는데 나는 nu라고 줄여 부르면 복사한 코드랑 안 맞기 때문에 섞여 가지고 난리가 납니다.

그래서 어지간하면 이런 거는 그냥 남들 하는 대로 따라 해 주시는 게 좋아요.

그래서 우리도 여기서 np라고 줄여 부르겠습니다.

그래서 이제 np에 보면은 product라는 함수가 있는데 product가 뭐냐면 수학에서 다 곱해라

이겁니다.

그래서 image.share에 보면은 shape에 있는 숫자를 다 곱해라.

그러면은 결국에는 0번 1번 2번 이렇게 곱할 필요 없이 그냥 다 곱해줍니다.

뭐 결과는 똑같겠죠.

## 이미지의 자료형

자 그다음에 38쪽으로 넘어가서 이미지점 D타입이라는게 있는데요 D타입은 뭐냐면 D가 데이터고 타입이 자료형 그러니까 어떤 컴퓨터에서 숫자를 나타낼 때 어떤식으로 나타내느냐 이게 자료형인데 숫자가 지금 어떤 형태로 표현이 되고 있느냐 이 얘기입니다

해보면 Uint8 이렇게 나와요

그럼 Uint8은 뭐냐 여기 맨 앞에 있는 U는 부호가 없다는 얘기입니다

부호가 없다는 얘기고 두번째 있는 int는 정수라는 뜻이에요

int죠

그 다음에 마지막에 8은 8비트라는 얘기입니다

8비트는 컴퓨터에서 기본적으로 모든 숫자를 이진수로 표현하는데 8비트라는 것은 이진수 8자리라는 이진수 8자리로 나타낼 수 있는 숫자는 2에 8승계이기 때문에 총 256개가 됩니다

근데 컴퓨터에서는 항상 0부터 숫자를 표현하니까 0부터 255까지의 숫자가 됩니다

그래서 0이 가장 어두운 거기 때문에 검은색이 되구요

255가 컴퓨터에서 나타낼 수 있는 가장 큰 밝기가 됩니다

그래서 이게 흰색이 되요

그래서 이 숫자가 255가 컴퓨터에서 나타낼 수 있는 가장 큰 밝기가 됩니다

그래서 이게 흰색이 되요

그래서 이 숫자들은 좀 기억을 해주시면 좋습니다

그래서 기본적으로 이제 색깔 하나를 0에서 255 의 단계로 총 밝기를 255단계로 표현하는거죠

그래서 이제 uint8 이라는 자료형을 쓰게 되구요 그래서 보통 오픈CV에서 쓰는 자료형이 두가지인데 uint8 아니면 flut32 입니다

flut32는 flut32는 32비트로 표현을 하는데 부동소수점 방식으로 표현을 해요

부동소수점이 뭔지는 좀 있다 얘기하구요

그래서 요거는 실수로 표현할 때 쓰는데 주로 이제 숫자를 이미지를 0에서 1 또는 마이너스 1에서 플러스 1로 표현을 합니다

그래서 만약에 0에서 1로 표현하면은 0이 검은색이고 1이 흰색이 되겠죠

0이 검은색이고 1이 흰색이 되겠죠

그 다음에 마이너스 1에서 플러스 1로 하면 마이너스 1이 검은색이 되고 1이 검은색이 되겠죠

그래서 그렇게 실수로 표현하는데 왜 실수로 표현할 때는 0에서 1이나 마이너스 1에서 플러스 1로 하느냐 왜 실수로 표현할 때는 0에서 1이나 딱히 대단한 이유가 있는건 아니구요 숫자가 너무 커지면 계산할 때 여러가지 번잡한 문제가 생기기 때문에 보통 이제 0 근처에 우리가 고등학교 다닐 때도 보면은 수학문제 주관식인데 잘 모르면 찍는게 0,1 뭐 이런거잖아요

수학에서 0이나 1같은거는 좀 취급하기 편리한 측면이 있거든요

좀 취급하기 편리한 측면이 있거든요

그래서 편리하게 0에서 1 또는 마이너스 1에서 플러스 1 이렇게 실수로 표현을 합니다

만약에 이거를 마이너스 1에서 플러스 1로 변환하면 0은 마이너스 1이 되고 255는 플러스 1이 되야 되니까 어떻게 하면 되겠어요

어떻게 하면 되겠어요

나누기 127.5 빼기 1 하면 되겠죠

정수로 표현된거를 나누기 127.5 빼기 1 하면은 나누기 127.5 빼기 1 하면은 255가 들어가면 255 나누기 1이 되겠죠

255가 들어가면 255가 들어가면 255가 들어가면 227.5하면 2가 되니까 2 빼기 1 해서 플러스 1이 되고 0이 들어가면 0 빼기 1이니까 마이너스 1이 되고 이런식으로 환산을 합니다

그래서 이제 주로 우리가 이미지를 그냥 원본 그대로 놔둔 상태에서 픽셀들을 더하고 빼고 하거나 단순 계산을 할 때는 정수 단위로 처리를 하고요

뭔가 머신러닝같은 복잡한 계산을 하면 숫자를 곱하거나 계산을 해야 되는데 그때는 예를 들면 255에다가 2를 곱해버리면 숫자가 500 얼마 이렇게 늘어나버리잖아요

그럼 다시 밝기를 조정을 해주려면 굉장히 계산이 번잡하단 말이에요

그래서 보통은 실수로 바꿔서 계산을 하고 마지막에 파일로 저장을 한다던가 이럴 때 최종적으로 0에서 255로 다시 한번 변환을 해주는 그런 방식으로 합니다

우리가 한동안은 플러스 32로 다루는거는 볼일이 좀 없고 정수 단위의 단순한 처리들부터 볼겁니다

## 부동소수점 실수
그 다음에 제가 부동소수점이라는 얘기를 했는데요 이거는 꼭 자세히 아셔야 되는건 아닌데 그래도 대강이라도 알아두시면 좋습니다

부동은 영어로 float 이렇게 쓰는데 둥둥 떠다닌다

이런 얘기에요

그래서 부동소수점보다는 둥둥소수점 이렇게 얘기하면 기억하기가 쉽거든요 소수점이 둥둥 떠다닌다고 해서 둥둥소수점입니다

소수점이 둥둥 떠다닌다는 소리가 뭐냐 32비트라는 건 이진수로 32자리라는 얘기인데 이진수로 32자리면은 대충 뭐 얼마일까요 이진수로 32자리면 대충 뭐 얼마일까요 이진수로 32자리면 이진수로 32자리면 이진수로 32자리면 대충 10진수로 10짜리 정도 되거든요

10짜리면은 한 100억 정도 되겠죠

기본적으로 숫자를 0부터 100억 정도까지 표현할 수 있는데 우리가 소수점을 찍어야 되는데 예를 들면은 10진수로 10자리란 말이야 1 2 3 4 5 6 7 8 9 10 자릿수가 고정이 되어있는데 만약에 소수점을 여기다가 딱 찍어버렸다 그러면은 뒤로 소수점 밑으로는 두 자리까지 표현할 수 있고 소수점 앞으로는 8자리까지 표현할 수 있는 거죠

10진수로 치면 그럼 문제가 뭐냐면 우리가 예를 들면은 원주율 같은 거를 표현하고 싶다

원주율이 3.141 이렇게 나가는데 여기서부터는 표현을 못해요

그럼 앞에는 쓸데없이 자리가 남잖아요

그죠

그리고 뒤에는 너무 많이 잘려 나간다 소수점이 고정이 되어있으면 요런 점이 좀 나쁩니다

이런 데가 낭비에요

작은 수를 표현할 때 예를 들면 0.005 이런 걸 표현하려면 0.005 여기서부터 쓸 수가 없네

이렇게 됩니다

그래서 둥둥 소수점은 둥둥 떠다닙니다

만약에 원주율 같은 거 표현하고 싶다 그럼 소수점을 앞으로 옮겨 놓으면 되겠죠

그러면 3.141 이렇게 충분히 자릿수를 표현할 수가 있습니다

그래서 소수점의 위치가 둥둥 떠다닌다고 해서 둥둥 소수점 플러팅 포인트라고 해요

근데 이게 문제가 있는데 뭐냐면 실수 계산이 정확하게 안 돼요

그 실수 계산을 해보면은 예를 들어서 우리가 컴퓨터에서 0.1하고 0.2하고 더하면 끝에 이렇게 이상한 그런 게 붙습니다

근데 요거는 사실 이제 요런 것도 있고 또 하나는 우리가 아주 큰 숫자라 ...

아주 작은 숫자를 더하면 이 두 가지를 동시에 표현할 수가 없습니다

왜냐면 이거는 소수점이 되게 뒤에 붙어있고 이건 소수점이 되게 앞에 붙어있어가지고 두 개를 더해버리면 이게 1, 2 플러스 23 이렇게 한 거는 10에 23승이라는 얘긴데 그러니까 뒤에 있는 요런 작은 숫자가 그냥 날라가버려요 서로 자릿수가 안 맞기 때문에 큰 쪽에다가 소수점 위치를 맞춰버리거든요

그래서 실수 계산은 이 부동소수점 방식으로 표현하는 한에서는 뭐 아주 정확하지는 않습니다

대충 근사적으로만 맞지 자릿수의 어떤 그런 제한때문에 정확하게 맞진 않아요

그럼 어떻게 하느냐

뭐 사실 별 문제는 없습니다 별 문제는 없는데 아주 정확하진 않다

그런 점은 기억을 해주시면 되겠고 그러면은 더 정확하게 하려면 어떻게 하면 되겠어요

이거 비트수를 높여버리면 되겠죠

64비트 이렇게 높이면은 더 정확하게 표현을 할 수 있습니다 오차가 좀 줄어들겠죠 자릿수가 더 많이 표현할 수 있으니까 근데 어 그 대신에 뭔가 자릿수가 많아지니까 계산도 쓸데없이 늘어나는 점이 있어요

그래서 우리가 머신러닝에서는 대부분 그렇게까지 정확하게 계산할 필요가 없거든요

그래서 보통은 자릿수를 좀 줄입니다

16비트 8비트 이렇게 그래서 요즘에는 심지어 3비트까지 줄이는 경우도 나오는데 3비트가 아니라 1.5비트 더 줄이는 경우도 나오는데 왜냐하면은 아까도 보셨지만 그래픽카드 이런게 용량이 크면 굉장히 비싸단 말이에요

그러면은 계산의 정확도를 조금 희생을 하면 어 그 용량을 확 줄일 수가 있으니까 반으로 줄일 수 있잖아요

이렇게 한번 줄일때마다 반씩 줄어드니까 요즘에는 이제 이렇게 용량을 줄여서 쓰는 경우도 많이 있습니다

그래서 항상 정확하게 하지는 않는다

오히려 약간 부정확하게 하는게 더 나을 때도 있다 용량 측면에서 그렇습니다

어 그 다음에 여기 좀 이상한 코드가 있는데요 이게 코드가 좀 복잡하니까 이거는 직접 타이핑하지 마시고 복사해서 써보시면은 아 임포트가 빠졌군 임포트 스트럭트 이렇게 해보시면 이게 뭐냐면은 어 어떤 1이라는 숫자가 있을 때 이게 부동소수점 방식으로 실제로 컴퓨터 내부에서는 어떻게 표현되느냐 이거를 이제 보여주는거에요

그래서 예를 들면은 10 이렇게 하면은 예 이렇게 되고 여기다가 이제 20 하면은 이렇게 되고 10 10 10 10 그래서 컴퓨터 내부적으로 그 어떤 숫자가 어떻게 표현되는지 약간 복잡한데 이런식으로 하면은 요 숫자가 그 컴퓨터 내부에서 어떤 식으로 이제 표현되는지 우리가 알 수가 있습니다

1하고 2로 할까요

1 2 이렇게 그래서 컴퓨터 내부에서는 요 숫자는 사실 이런식으로 표현이 된다

이런거고 앞에 마이너스를 붙여보면 맨 앞에가 0에서 1로 바뀌었죠

이게 플러스 마이너스를 나타내는 비트입니다

이런식으로 각각의 비트가 어떤식으로 표현되는지 그래서 프로그래밍 경험이 적으신 분들은 그거를 항상 생각을 좀 해두셔야 되는데 우리 눈에 보이는거랑 컴퓨터 내부에서 뭐가 어떻게 되는거랑 좀 다르다

이거를 좀 염두에 두셔야 돼요

컴퓨터 내부에서는 모든게 다 이진수거든요

근데 우리 눈에 보여줄 때는 이렇게 저렇게 다양하게 보여주지만 결국엔 내부적으로 들어가면 다 이진수입니다

뭐든지 다 이진수고 그래서 우리가 그 이진수 표현을까지 아실거는 없는데 좀 다르게 표현될 수 있다

이거를 좀 기억해두시면 좋고 또 하나는 컴퓨터 내부로 들어가면 결국 다 이진수라는게 굉장히 중요한 부분인데 왜 중요하냐면 우리가 이미지도 결국 컴퓨터 내부로 들어가면 어떤 이진수에요

숫자도 컴퓨터 내부로 들어가면 이진수에요 음성도 이진수에요

영상도 이진수에요 텍스트도 이진수에요

결국 뭐냐면 컴퓨터 내부에서는 모든게 똑같이 다 그냥 이진수거든요

그러면 우리가 그런 생각을 할 수 있죠

어차피 이미지 처리라는건 그 이진수를 가지고 뭔가 더하고 빼고 곱하고 나누고 계산을 하면 짜잔 하고 뭐가 나오는거야

자연어 처리는 뭐냐면 자연어를 이진수로 바꾼 다음에 또 더하고 빼고 곱하고 나누고 하면 짜잔 하고 갑자기 컴퓨터가 말을 알아듣는 것처럼 됩니다

음성인식 또 음성을 소리를 이진수로 바꿔서 또 더하고 빼고 곱하고 나누고 계산을 하면 짜잔 하고 음성이 텍스트로 바뀌어요

그러니까 우리가 컴퓨터에서 어떤거를 처리할 수 있는 한 머신러닝은 결국 본질적으로는 똑같은 것이다

결국 숫자를 더하고 빼고 곱하고 나누고 하면 짜잔 하고 뭔가 된다

이것이 굉장히 중요한 부분입니다

그래서 가끔 이제 뭐 이런 분들이 있거든요

뭐 뭐를 xx를 어떻게 숫자 계산으로 나타낼 수 있냐

말이 안 된다

말이 되죠

왜 안 돼요

컴퓨터에서 표현을 할 수 있다는 것 자체가 이미 숫자로 표현할 수 있다는 거죠

예전에 제가 자연어 처리 관련해서 어디서 이렇게 얘기를 할 때 이제 보통 인간의 언어라는게 얼마 약간 옛날 얘기인데 인간의 언어라는게 얼마나 뭐 이렇고 저렇고 하는데 그걸 어떻게 숫자로 표현하냐

근데 사실 옛날에도 컴퓨터로 표현을 했었는데 사실 옛날에도 컴퓨터로 표현을 했었는데 사실 옛날에도 컴퓨터로 표현을 했었는데 그거를 그대로 텍스트를 파일로 지금처럼 뭐 채찍이 이런 게 없었다 뿐이지 파일로 저장하고 이런 건 다 됐잖아요

인간의 언어를 그때도 숫자로 다 저장을 하긴 했습니다

그러니까 뭔가 우리 눈에 보이는 것과는 다르게 컴퓨터 내부로 들어가면 다 숫자고 우리가 그 숫자를 더하고 빼고 할 수 있는 이상 다 머신러닝을 적용을 할 수는 있다

물론 성능이 잘 나오고 안 나오고는 차이가 있을 수 있는데 본질적으로 하면 다 똑같다

이런 얘기가 됩니다

자 그 다음에 뭐 이거는 그냥 약간 교양이라고 생각하시면 될 것 같고요 몰라도 그만입니다

내부적으로 이게 어떻게 되는지 어쨌든 계산이 그렇게 정확하지는 않다는 것만 기억을 해 주시면 되겠어요

## 이미지 보기

```python
cv2.imshow('image 1', image) # 제목이 image 1인 창에 이미지 표시
cv2.waitKey(0)  # 아무 키 입력을 기다림. 인자는 대기 시간(밀리초), 0일 경우 계속
cv2.destroyAllWindows()  # 모든 창 닫기
```

그 다음에 이미지를 보고 싶은데 숫자가 아니라 우리는 눈에 보이는 게 중요하죠

그럼 이제 이미지를 보려면 어떻게 하면 되느냐 두 가지 방법이 있어요

오픈CV 자체에서 제공하는 게 있고 그 다음에 우리가 아까 했던 PIL을 이용하는 방법도 있고 이런 방법이 있는데 일단 오픈CV에서 제공하는 방법으로 한번 봅시다

그래서 이것도 코드가 좀 기니까 복사해서 쓰죠

요 코드를 실행을 하면은 이렇게 창이 하나 새로 뜨거든요

창이 하나 새로 뜨면서 이 이미지를 보여줍니다

그래서 CV2.IMshow 하면은 색칠을 해봅니다.

세 창을 이렇게 하나 띄워줘요 세 창을 하나 띄워주고 그 다음에 여기 상단에 이미지 1이라고 돼 있는데 여기가 이제 세 창에 써 있는 글자가 됩니다

그 다음에 이 이미지 숫자를 여기 이 창에 그림으로 뿌려줍니다

그 다음에 CV2.weightkey0 이렇게 돼 있는데 키의 k는 대문자입니다

이거는 뭐냐면 뭔가 키 입력을 기다려요

여기다가 이제 엔터를 치면은 창이 사라집니다

왜냐하면 키의 k를 하는 동안은 기다리다가 입력이 되면은 다음으로 넘어가요

근데 그 다음이 뭐냐면 디스트로이 올 윈도우즈에서 CV2 띄웠던 이 imchow로 띄웠던 창을 디스트로이 부숴줍니다

창이 부숴져서 없어져요

그래서 여기 이제 0은 기다리는 시간입니다

그래서 얼마나 기다릴 거냐

이건데 이게 이제 밀리초 1,000분의 1초 단위기 때문에 예를 들어서 여기다가 1,000 이렇게 하면은 1,000 밀리초 하면 1초거든요 1초 동안 키를 기다리고 만약에 없으면 그냥 넘어갑니다

그래서 1초는 좀 짧으니까 한 3,000 이렇게 해봅시다

그러면은 하나 둘 셋 저절로 없어지죠

제가 키보드 안 건드렸는데 3,000 밀리세컨드를 기다리고 키 입력이 없으면 그냥 사라집니다

근데 이제 0 하면은 계속 기다려요

0초 기다리는 게 아니라 계속 기다려요

그래서 뭐 이런 식으로 이제 이미지를 보실 수도 있습니다

이거는 한번 해보시고요

그래서 이제 0 했을 때 떴을 때 창은 이거 X 눌러서 닫지 마시고 이 창을 이제 띄운 상태에서 뭐 아무거나 키보드의 키를 누르시면 돼요

그럼 바로 없어집니다

```python
from PIL import Image # Pillow 라이브러리 임포트
def show(image):
    rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) # BGR → RGB로 채널 순서 변경
    return Image.fromarray(rgb) # 객체 변환: 넘파이 배열 → PIL 형식으로
show(image)
```

자 그 다음에 이렇게 세창을 뛰어서 볼 수도 있는데 좀 불편하거든요

사실 그래서 저는 어떻게 하냐면 그 PIL 우리가 앞 시간에 했던 이걸로 보는데 어떻게 하냐면 사실 되게 쉬워요

오픈CV에서 지금 이미지가 BGR 순서로 돼 있거든요

그래서 이거를 RGB 순서로 일단 바꿔줍니다

왜냐하면 PIL이랑 호환성을 위해서 그래서 여기 대문자로 시작하는 이미지 우리 앞 시간에 했던 거죠

여기에 FROMARRAY라는 함수가 있어요

아까는 오픈이라고 해서 파일에서 여는 걸 했는데 FROMARRAY 하면은 말 그대로 배열에서 이겁니다

이게 이제 배열로 돼 있기 때문에 배열에서 변환을 해줘요

그래서 이거는 뭐냐면 파이썬에서 함수를 정의하는 구문입니다

DEF하면 Define 함수를 정의를 하겠다

이런 얘기고 어떤 함수를 정의하냐 SHOW라는 함수를 정의하는데 이 함수는 이미지를 하나 인자로 받아요

그래서 그 이미지의 BGR을 RGB로 바꿔주고 그 다음에 PIL의 방식으로 이미지를 다시 부른 다음에 리턴, 되돌려 주는 거예요

그래서 여기다 SHOW에다가 우리가 지금 가지고 있는 이 이미지를 넣어주면 이 처리가 된 결과를 해줍니다

이것도 코드가 좀 기니까 그냥 복사해서 쓸게요

여러분도 이런 거는 뭐 일일이 타이핑하실 필요 없이 복사해서 쓰시면 돼요

그러면은 아까 PIL처럼 그냥 이 화면에서 바로 볼 수 있죠

그래서 이 이미지는 지금 OpenCV로 불러드린 건데 SHOW 함수에다 넣어주면은 아까 PIL처럼 그냥 주피터 노트북 안에서 보실 수 있습니다

그래서 이 SHOW 함수를 정의를 해 놓고 우리 수업에서는 그냥 이 SHOW 함수를 계속 쓸 겁니다

이거는 복사해 놓고 수업 시작할 때 한번 붙여 넣어서 실행을 해서 함수를 정의를 해 주시면 되겠어요

이거는 탭키를 눌러서 길어쓰기를 해주세요 길어쓰기를 왜 해주냐면 함수가 어디서부터 어디까지인지 표시를 해주는거에요


## PIL과 넘파이간 형식 변환

```python
import numpy as np
pil_img = Image.open(image_path)  # Pillow로 파일을 연다
np.array(pil_img)  # 배열로 변환
```

자 그래서 이제 방금 보면은 배열을 PIL 형태로 변환하는걸 했는데 여기 밑에 있는 이 코드죠

from array 해가지고 이미지를 넣어주면 PIL 형태로 바꾸는데 반대로 PIL 형태로 되있는거를 numpy 배열로 바꾸고 싶다

그러면은 np.array 라는 함수를 쓰면 됩니다

예를 들면 우리 이미지.open 이걸로 열었다

지난 시간처럼 그래서 이걸로 열었으면 np.array로 넣어주면 배열로 바뀝니다

그래서 이제 opencv 하고 PIL하고 왔다갔다 할 수가 있어요

opencv에서 작업한거를 PIL로 보내려면 이렇게 하면 되고 반대로 PIL에서 작업한거를 opencv로 보내려면 np.array 이래서 배열로 바꾸시면 됩니다

그래서 왔다갔다 하면서 작업을 할 수 있어요

이걸로 했다가 이걸로 했다가 이걸로 했다가 이렇게 하면 되겠죠

그래서 이제 opencv를 다 쓸 수 있으면 상황에 따라서 편한걸 쓰면 되겠죠

근데 이제 한가지 주의하셔야 되는거는 PIL은 rgb 순서고 그 다음에 opencv는 순서가 bgr이다

요거는 염두에 두셔야 대부분은 별 문제가 없거든요

맨 마지막에 한번만 순서를 바꿔주면 되기 때문에 별 문제가 없는데 가끔 이제 사실 이걸 안하셔도 별 문제 없는데 여기 보면은 순서 바꿔주는거 있죠

요거를 빼먹으면 어떻게 되느냐

색깔이 반대로 뒤집혀 색깔이 지금 보면은 멀쩡해 보이지만 하늘이 벌겋게 됐죠

rgb 순서가 반대라서 요걸 안하시면 큰 문제는 아닌데 색깔이 반대로 뒤집혀 나온다

반대로 뒤집혀 나온다

그러면은 아니 뭐 색깔이 뒤집혀 나오는게 왜 별 문제가 아닙니까

큰 문제지라고 생각하실 수 있는데 한번 더 뒤집으면 되요

왜냐면 숫자는 똑같으니까 순서만 달라진거잖아요

색깔이 뒤집힌거는 사실 별로 큰 문제는 아니고 그냥 다시 뒤집어주면 되요

어차피 그 숫자가 날라간건 아니니까 표현하는 순서의 문제니까 빼먹지만 않으시면 된다

그런 문제는 아니다

그리고 대부분 컴퓨터 비전에서 이미지 처리를 할 때 빨간색인지 파란색인지는 별로 그냥 고려하지 않고 처리를 하거든요

어차피 그냥 어떤 밝기에 지나지 않기 때문에 그래서 사실 그게 뭐 빨간색인지 초록색인지 순서가 어떻게 되는지는 대부분의 경우에 처리에 영향을 주진 않습니다 맨 마지막에 화면에 뿌릴 때만 중요해요

## 비디오 처리

```python
video = cv2.VideoCapture('자전거.mp4')

fps = video.get(cv2.CAP_PROP_FPS)

frame_interval = int(1000 / fps)

while(video.isOpened()):  # 파일이 열려있는 동안
    ret, frame = video.read() # 한 프레임 읽음
    if not ret: # 없으면
        break # 중단
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # 흑백으로
    cv2.imshow('frame',gray) # 출력

    if cv2.waitKey(frame_interval) == ord('q'): # 키 입력을 기다림, q가 입력되면
        break # 중단
video.release() # 파일 닫음
cv2.destroyAllWindows() # 창 닫음
```

그 다음에 비디오도 처리를 할 수 있는데 여기 보시면은 자전거.mp4 라는 영상이 있습니다

약간 웃긴 영상인데요

보시면은 어 왜 이게 자전거지 이런 동영상이 있거든요

그 스케이트보드를 타고 가다가 넘어졌는데 그 스케이트보드에 자전거가 걸려서 자전거 타는 사람이 강에 빠지는 영상입니다

그래서 이제 오픈CV는 동영상도 처리를 할 수 있어요

그래서 아까 동영상 처리 어떻게 하냐 질문하신 분이 있는데 사실 동영상도 별거 아니고 이미지가 연속으로 쭉 있는 겁니다

그래서 어떻게 하냐면 이제 cv2.videocapture 해가지고 여기다가 동영상 파일 이름을 써주시면은 비디오에 동영상이 들어가요

그 다음에 이제 초당 프레임수가 무슨 말이냐면 보통 이제 동영상이 있으면 실제로는 사진이 1초에 몇 번씩 따라라라락 하고 넘어가거든요

그래서 그거를 fps라고 하는데 어 프레임 퍼 세컨드 그러니까 초당 프레임이 몇 장 지나가냐

그럼 요거가 이제 파일 안에 저장이 되있기 때문에 몇 장인지를 볼 수가 있습니다

보면은 25.0 이렇게 나오죠

무슨 말이냐면 이 파일에서는 초당 25장씩 이미지가 지나가도록 되어있는 동영상 파일이다

이겁니다

그러면은 이제 이거를 우리가 강의를 하고싶다

그러면은 1초에 한장을 얼마동안 보여줘야 되는지 결정을 해야겠죠

그러면은 1초에 25장이 지나가야 되니까 한장은 0.04초 뭐 이정도 보여주면 되겠죠

그래서 우리 강의자료에 보면은 프레임 인터벌이라고 있는데 그 1000 1000ms가 1초니까 1000을 fps로 나누면 사진 하나를 40ms 보여주면 되겠다

이렇게 알 수가 있습니다

그래서 이제 비디오 재생을 하는 코드가 좀 긴데 요거는 그냥 복사해서 쓰세요

근데 이제 복사해서 쓰실 때 여기 들여쓰기가 중요합니다

그래서 코드 설명을 먼저 좀 드리고 이게 pdf에서 쓰실 수 있어요

이거 복사하면은 이제 약간 들여쓰기가 깨져가지고 그래서 이제 코드 설명을 좀 드리면 while은 뭐냐면 요 뒤에 있는 조건이 참인동안 이런 뜻입니다

뭐뭐인 동안 영어로도 while하면 뭐뭐인 동안이죠

어느 동안 하냐면 비디오가 열려있는 동안 비디오가 열려있는 동안 요 아래를 다 하는데 그래서 들여쓰기가 보시면은 요기까지가 다 들여쓰기가 되어있어요

이만큼이 다 들여쓰기가 되어있습니다

비디오가 열려있는 동안은 요 작업들을 반복을 해라

근데 이제 비디오.

릴리즈는 줄이 while하고 똑같거든요

그 얘기는 뭐냐면 요거는 while에 걸려있는게 아니라는 얘기죠

이게 다 끝나면 요걸 하는겁니다

다 끝나면 뭐하냐면 비디오를 릴리즈를 해요

릴리즈는 이제 놓아준다

이런 얘기죠

그래서 열려있는 동안은 여기 있는걸 반복해서 하고 다 끝나면 파일을 놓아주고 창을 닫아라

이런 얘기에요

그럼 열려있는 동안 뭐하냐면 비디오.

리드 이렇게 하면은 한 프레임씩 파일에서 읽어옵니다

한 프레임씩 읽어오는데 요기 ret라는게 있거든요

그래서 ret가 이제 읽히는지 안 읽히는지 이런거에요

그래서 만약에 읽어오는데 실패했다

그 얘기는 이제 더 이상 프레임이 없다는 얘기죠

파일에 그래서 if not read 이렇게 하면 이제 이제 read은 이제 return 돌아온거에요 돌아온게 없으면 영어로 그냥 읽으시면 되겠죠

만약에 돌아온 것이 없으면 break 멈춰라

이거에요

break 밟아라

이거에요

그래서 이제 반복을 하다가 여기서 break를 만나면 다 중단되고 여기로 넘어갑니다

그 다음에 어...

뭐 이거는 그냥 뭐 사실 할 필요는 없는데 그냥 한번 넣어봤는데 어떻게 한거냐면 프레임을 이제 칼라로 출력하고 싶으면 그냥 출력하면 되는데 내가 흑백으로 찍고 싶다 화면에 출력하고 싶다

그러면 원래 bgr인데 이거를 그레이로 바꿔가지고 imshow해서 이렇게 그레이로 화면에 뿌려주면 됩니다

요거는 아까랑 똑같죠

그 다음에 우리가 지금 40ms를 기다렸다가 그 다음 이미지로 넘어가야 되잖아요

그래서 wait 키 해가지고 40ms 동안 어...

기다립니다

40ms를 기다리는데 만약에 그 40ms 안에 알파벳 q가 들어오면 ordq 이렇게 하면 q가 그 q라는 키에 숫자 값이 있거든요

그래서 들어온 입력키가 q라는 키랑 똑같은 키면은 또 중단을 해요

근데 만약에 q가 안들어왔다 그러면은 그냥 여기는 40ms 기다렸는데 아무것도 없었으니까 다시 앞으로 돌아갑니다

그래서 그거를 계속 반복을 하는거에요

언제까지?

더이상 프레임이 없을때까지 그래서 요거를 해보면itet 이렇게 어이쿠 넘어지고 이렇게 가다가 어이쿠 한다음에 으아 하고 저절로 다치죠

그래서 이제 흑백으로 하는건 이렇게 했는데 칼라로 하려면 어떻게 하면 되겠어요

그냥 프레임을 그대로 출력해주면 됩니다

이렇게 해보면 파일을 다 닫았지?

파일을 여는 것 부터 다시 하셔야 돼요

지금 보시면 칼라로 나오죠

그래서 여기 그레이를 여기다가 넣으면 그레이가 출력되는데 프레임을 넣으시면 그대로 프레임 을 넣어요

아까 이제 여기 어 rgb 로 바꾸면 어떻게 되나요 하셨는데 rgb 로 바꾸면 어떻게 될까요

이게 화면에 출력할 때 cv2의 imshow 로 하면 cv2의 imshow는 파일이 bgr이 돼 있다는 전제하에서 화면에 출력을 합니다

rgb 로 바꾸는 거는 pil 을 쓸 때 얘기예요

근데 지금은 우리가 cv2로 출력을 하잖아요

그럼 어떻게 되겠어요

색깔이 뒤집혀서 나오겠죠

아 파일이 또 닫았지

아 파일이 또 닫았지 파일 여는 것 부터 다시 하면 그럼 지금 보면 사람 얼굴이 파랗게 나오잖아요

보이시나요 잘 안 보이긴 하는데 그래서 opencv만 쓰실 거면 rgb 로 뒤집으시면 안 됩니다

원래 얘는 bgr 순서로 다 전제되고 모든 함수가 만들어져 있어요

그래서 칼라로 하시려면 그냥 아무것도 안 하시고 그냥 바로 프레임을 내보내시면 됩니다

그래서 cv2로 출력을 하면 rgb 로 바꾸면 cv2로 출력을 하면 rgb 로 바꾸면 cv2로 출력을 하면 rgb 로 바꾸면 cv2로 출력을 하면 rgb 로 바꾸면 cv2로 출력을 하면 rgb 로 바꾸면 cv2로 출력을 하면 rgb 로 바꾸면 cv2로 출력을 하면 rgb 로 바꾸면 그래서 이제 43초 비디오 재생하는 부분 이거 해보시고 이게 한번 하고 나면 파일이 닫혀가지고 다시 하시려면 여기 꼭 파일 여는 것부터 다시 하셔야 돼요

그래서 이제 이렇게 하시면 되고 이거 흑백으로도 화면에 출력해 보시고 제가 방금 한 것처럼 해가지고 컬러로도 출력해 보시고 에러 나거나 잘 안 되거나 질문 있으시면 말씀해 주세요

방금 아주 중요한 질문을 해주셨는데 이게 약간 주피터 노트북이 여기 있구나

여기 여기 주피터 노트북이 초보자들한테 좀 이상한 게 이게 단축키를 먹는 방식이 달라요

보통 단축키가 컨트롤이나 알트랑 같이 누르게 되어있잖아요

얘는 어떤 식이냐면 여기 보시면 커서 깜빡거릴 때는 그냥 일반 입력 모드인데 여기서 ESC를 한 번 누르면 이렇게 회색으로 바뀌면서 단축키 모드로 바뀝니다

이때는 예를 들면 그냥 X를 누르면 잘라내기가 되고 V를 누르면 붙여넣기가 되고 이런 식이에요

그래서 컨트롤 X가 아니라 그냥 X만 누르면 그냥 잘라내기가 됩니다

그래서 이렇게 한 번 누르면 그냥 X만 누르면 그냥 잘라내기가 됩니다

이렇게 회색이 되어있을 때는 이게 단축키 모드거든요

단축키 중에 무슨 단축키가 있냐면 예를 들면 1 더하기 1 이렇게 있는데 단축키 중에 M을 누르면 이게 코드가 아니라 텍스트로 취급이 돼요

그래서 이걸 실행을 해도 실행이 안됩니다

왜냐면 그냥 텍스트라서 그래서 이거는 중간에 뭐 설명 같은 거 써놓을 때 쓰는 거거든요

그래서 이렇게 되어있으면 단축키로는 Y를 누르시면 되는데 단축키를 외우기가 어려우니까 여기 보시면 상단에 코드라고 되어있거든요

여기 보시면 상단에 코드라고 되어있거든요

그래서 이게 마크다운으로 되어있으면 텍스트로 바뀌는데 어떻게 하냐면 코드일 때는 옆에 이렇게 각괄호가 있어가지고 실행하면 몇 번째로 실행한 셀이다

이걸 표시를 해줍니다

근데 이게 마크다운이 텍스트라는 뜻인데 텍스트로 바꾸면 실행을 안하기 때문에 옆에 숫자 표시하는 게 없어요

그래서 가끔 하다 보면 실수로 단축키가 눌려가지고 이게 텍스트로 바뀌었을 때가 있거든요

자주 있는 일입니다

그래서 그때는 여기 상단에 마크다운으로 되어있는 거를 코드로 바꿔주시면 돼요

그 다음에 실행하시면 잘 실행이 됩니다

이게 이제 익숙한 사람들은 컨트롤 안 눌러서 좋다고 이렇게 만들어 놓은 건데 사실 안 익숙한 사람들한테는 대혼란을 불러일으키는 방식이라서 사실 별로 좋은 UI라고 생각을 안 하는데 이게 약간 자동차가 자동차랑 비슷해요

자동차 오른발로 브레이크도 밟고 엑셀도 밟고 하면 초보자들은 굉장히 헷갈려지지만 익숙해지면 되게 편하잖아요

## 웹캠

```python
video = cv2.VideoCapture(0)
```

자 그래서 이렇게 우리가 비디오를 재생을 할 수 있구요 어 똑같은 방식으로 웹캠도 캡쳐를 할 수 있는데 웹캠을 캡쳐 하려면은 여기 파일을 불러올 때 파일 이름 대신에 거기다 숫자 0 이라고 쓰시면 됩니다

근데 실행을 하셔도 안되겠죠

왜까요 우리 실습 컴퓨터 웹캠이 없기 때문입니다

그래서 수업을 할 때 그 실습용 컴퓨터를 노트북으로 주면은 우리가 이걸 해볼 수가 있는데 안타깝게도 데스크탑이라 웹캠이 없네요

사용방법이 똑같기 때문에 이건 나중에 이제 여러분들 집에 노트북이 있으시면은 한번 해보시거나 아니면 이제 어디서 웹캠을 가져오셔서 usb 를 꽂으시면 됩니다

그래서 똑같은 코드에다가 비디오 재생 이런것도 똑같고 다 똑같이 하시고 여기 맨 앞에 파일 이름만 숫자 0으로 바꿔 놓으면은 웹캠을 재생을 합니다

웹캠은 끝이 안나니까 계속 무한 재생이 되겠죠

q 누르기 전에 어 그래서 웹캠은 뭐 없어서 못해보는데 사용방법은 똑같으니까 그냥 요거랑 똑같다

이렇게 생각하시면 되고 뭐 뭐 별거 없죠

그리고 여기 보시면 프레임이 결국에는 그냥 이미지거든요

그래서 화면에 보여줄 때도 영상 재생을 하는데 그냥 이렇게 재생을 하면은 이 프레임이 그냥 이미지거든요

그래서 화면에 보여줄 때도 영상 재생을 하는데 따로 뭐가 있는게 아니라 그냥 40ms 마다 화면에 보여주는 그 이미지를 40ms 간격으로 계속 바꾸는 거에요

우리 눈에는 영상처럼 보이지만 실제로 굉장히 빠르게 이미지를 그냥 넘기는 거에 불과하거든요

그래서 여러분들이 동영상 처리라고 해도 뭐 특별히 뭘 하는게 아니라 그냥 이미지 처리 코드를 만들어서 여기다가 요 사이에다가 끼워 넣으시면 되는거에요

그러면은 40ms 마다 뭔가 이미지 처리를 빨리빨리 하게 해가지고 화면에 뿌려 주면 되겠죠.

화면에 화면에 뿌려 주면 되겠죠.

그리고 이제 뭐 사실 대부분의 경우는 그렇게까지 실시간으로 이미지를 처리해야 되는 경우가 잘 없거든요
