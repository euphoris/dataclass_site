# 변수의 변형
- 선형 모형은 독립변수와 종속변수의 선형적 관계를 가정한다는 한계
- 독립변수를 비선형 변환하면 이 한계를 일부 극복할 수 있음
- 예시: $z = \log x$, $\hat{y} = wz + b$
- Python은 관계식에 수학 함수를 사용하면 자동으로 변수 변환

## 왜도

*   데이터 분포의 **비대칭 정도**.
    *   `Negative Skew`: 왼쪽 꼬리 김 (- 방향 치우침). 평균 < 중간값 < 최빈값.
    *   `Positive Skew`: 오른쪽 꼬리 김 (+ 방향 치우침). 최빈값 < 중간값 < 평균.
*   **값 해석 (절대값 기준):**
    *   `0`: 좌우 대칭.
    *   `|0.5|`: 중간 정도 치우침.
    *   `|1|`: 극단적 치우침.

## 예시: 중고차 주행거리 분포

*   **히스토그램:** 오른쪽 꼬리 긴 형태 보임.

```python
import seaborn as sns
df = pd.read_excel('car.xlsx')
sns.histplot(x='mileage', data=df)
```

*   **왜도 계산:** `df['mileage'].skew()` 결과 > 1.04 → **+ 방향 매우 치우침**.

## 로그 함수

- 오른쪽 위로 갈 수록 완만해지는 형태
- 가로축에서 1, 10, 100이 세로축에서 같은 간격(예: 0, 1, 2)
- 데이터에 적용하면 오른쪽을 왼쪽으로 끌어당기는 효과
- 독립변수에 오른쪽으로 크게 떨어져 있는 값이 있는 경우(예: 소득), 로그 함수를 적용해주면 간격을 일정하게 만들어 줄 수 있음

## Python 회귀분석과 산점도

회귀분석  (R제곱은 0.457)
```python
ols('price ~ mileage', df).fit().summary()
```

산점도
```python
sns.lmplot(x='mileage', y='price', data=df)
```

## Python 로그 함수 적용

회귀분석  (R제곱: 0.479)
```python
import numpy as np
ols('price ~ np.log(mileage)', df).fit().summary()
```

산점도
```python
df['log_mileage'] = np.log(df['mileage'])
sns.lmplot(x='log_mileage', y='price', data=df)
```


## Box-Cox 변환

로그 변환의 일반화

$$
\frac{y^\lambda - 1}{\lambda}
$$

$\lambda=0$일 때는 로그 함수와 같음

```python
from scipy.stats import boxcox
df['mileage_tr'], lambd = boxcox(df.mileage)
lambd
```

회귀분석  (R제곱: 0.498)
```python
ols('price ~ mileage_tr', df).fit().summary()
```

히스토그램
```python
sns.histplot(x='mileage_tr', data=df)
```

산점도
```python
sns.lmplot(x='mileage_tr', y='price', data=df)
```

변환 함수의 시각화
```python
import matplotlib.pyplot as plt
x = np.linspace(0, 100, 100)
y1 = boxcox(x, lambd)
plt.plot(x, y1, label='Box-Cox')
y2 = np.log(x)
plt.plot(x, y2, linestyle='dashed', label='Log')
plt.legend()
```

## 독립변수의 서열을 이용한 회귀분석

- 독립변수의 서열(등수)이 1 변할 때 종속변수의 변화
- 스피어만 상관계수와 비슷한 논리
```python
price ~ mileage.rank()
```

- 장점
    - 표준화처럼 단위가 서로 다른 경우를 비교할 수 있다
    - 로그 함수처럼 한쪽으로 늘어진 데이터를 고르게 맞춰줄 수 있다
- 단점
    - 새로운 데이터는 기존 데이터의 등수에 맞춰서 등수를 산정해야 함(귀찮음)
    - 예측을 할 때 기존의 관찰 범위를 넘어서면 예측을 못함


## I() 함수

- 관계식에 덧셈, 곱셈, 거듭제곱 등을 할 경우 적용이 불가
- I 함수를 사용하여 이러한 계산을 적용 가능
```
price ~ I(my_car_damage + other_car_damage)
```

- 두 독립변수 x와 z를 더하여 하나의 변수로 변환


## 2차항(제곱항) 추가

- $y = w_2 x^2 + w_1 x + b$ 모형을 만들고 싶을 때
- 거듭제곱에 `**` 사용

```python
# y = w2*x^2 + w1*x + b 모형
y ~ I(x**2) + x
```

- $x^2$ : `I(x**2)`
- $x^3$ : `I(x**3)`
- $x^4$ : `I(x**4)`

## 절편 없는 모형

- 절편이 없는 모형(b = 0)을 표시하기 위해서는 관계식에 0 +를 추가

```
y ~ 0 + x
```

- 절편이 있을 때와 없을 때는 R제곱 계산 방법이 다름
- 절편이 있을 때: R제곱 = 1 - 잔차분산 / (평균으로 예측할 때의 잔차분산)
- 절편이 없을 때: R제곱 = 1 - 잔차분산 / (0으로 예측할 때의 잔차분산)


## 절편 없는 이차함수 예시: 제동 거리

```python
sp = pd.read_excel('speed.xlsx')

# 절편 없는 일차함수
ols('dist ~ 0 + speed', data=sp).fit()

# 절편 없는 이차함수 (speed^2 항 추가)
ols('dist ~ 0 + I(speed**2) + speed', data=sp).fit()
```

## 절편의 이동 (Centering)

- 절편은 x = 0일 때의 예측치
- 절편을 x = 2010일 때의 예측치로 바꾸려면 x에 일괄적으로 2010을 빼면 됨
```
price ~ I(year - 2010)
```
- 분석 자체에는 영향이 없으나 절편의 해석이 더 쉬워질 수 있음


## 퀴즈

<iframe src="https://tally.so/embed/31RjML?alignLeft=1&hideTitle=1&transparentBackground=1&dynamicHeight=1" loading="lazy" width="100%" height="2000" frameborder="0" marginheight="0" marginwidth="0" title="[통계] 변수의 변형"></iframe>
